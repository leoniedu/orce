[{"path":"https://leoniedu.github.io/orce/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 orce authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"introdução","dir":"Articles","previous_headings":"","what":"Introdução","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"otimização da coleta de dados é um desafio comum em instituições de pesquisa que lidam com grandes volumes de informações distribuídas geograficamente. caso IBGE, necessidade de otimizar alocação das Unidades de Coleta (UCs) se torna essencial, dada complexidade logística e os elevados custos envolvidos processo. pesquisas MUNIC (Pesquisa de Informações Básicas Municipais) e POF (Pesquisa de Orçamentos Familiares) são dois exemplos que ilustram importância dessa otimização. MUNIC, que coleta dados sobre gestão e estrutura dos municípios brasileiros, e POF, que investiga os hábitos de consumo das famílias brasileiras, envolvem coleta de dados em milhares de domicílios e municípios, gerando altos custos logísticos. O pacote orce é uma ferramenta projetada para otimizar alocação de Unidades de Coleta (UCs), como setores censitários, prefeituras de municípios ou estabelecimentos de ensino, às agências IBGE. eficiência dessa alocação é fundamental para garantir coleta de dados de forma econômica e eficaz em pesquisas e censos de grande escala, como o Censo Demográfico. Coletar dados em milhares de domicílios espalhados por um vasto território é um grande desafio. O orce entra em ação para ajudar definir melhor estratégia, minimizando o tempo de deslocamento e os custos envolvidos.","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"principais-características","dir":"Articles","previous_headings":"Introdução","what":"Principais Características","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Roteamento e Geocodificação: Utiliza o banco de dados CNEFE para obter coordenadas geográficas precisas para cada UC, garantindo acurácia cálculo de distâncias e rotas. função ponto_setor_densidade auxilia na identificação de locais representativos dentro dos setores censitários, priorizando áreas de alta densidade populacional para facilitar o acesso e garantir que o algorítimo de roteamento tenha destinos/origens válidos. Otimização Avançada da Alocação: O orce implementa um algoritmo inteligente que encontra melhor forma de distribuir UCs entre agências IBGE, levando em conta diversos fatores, como distância entre os locais, o tempo de viagem, os custos fixos de cada agência e necessidade de pagar diárias aos pesquisadores. função principal, alocar_ucs permite que você personalize restrições, como capacidade de cada agência e preferências de localização, para que alocação se adapte às necessidades específicas seu projeto. Cálculo de Custos Detalhados: O pacote considera fronteiras administrativas para determinar quando é necessário pagar diárias aos pesquisadores, garantindo que os custos totais sejam calculados com precisão. Outros custos importantes, como combustível e tempo de viagem, também são levados em conta para fornecer uma estimativa completa dos gastos da coleta de dados. Flexibilidade e Adaptabilidade: O orce permite que você personalize vários parâmetros, como o custo combustível, o custo por hora de viagem, o consumo de combustível por quilômetro e restrições específicas de cada agência. Essa flexibilidade garante que o pacote possa ser adaptado diferentes tipos de pesquisas e necessidades de coleta de dados, tornando-o uma ferramenta versátil para o IBGE.","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"impacto-e-aplicações","dir":"Articles","previous_headings":"Introdução","what":"Impacto e Aplicações","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"O pacote orce tem o potencial de gerar um impacto significativo na eficiência e na economicidade das operações de pesquisa e censo IBGE. Ao otimizar alocação de UCs, o pacote pode: Reduzir custos de viagem e tempo de deslocamento: Ao minimizar distâncias percorridas e o tempo gasto em viagens, o pacote contribui para redução dos custos operacionais e aumenta produtividade das equipes de coleta de dados. Otimizar utilização dos recursos das agências: alocação eficiente das UCs às agências garante que os recursos sejam utilizados de forma equilibrada. opção de impor límites máximos e mínimos de unidades de coleta por agência ajuda evitar sobrecarga em algumas agências e ociosidade em outras. Facilitar o planejamento e gestão da coleta de dados: capacidade de personalizar parâmetros e restrições permite que o pacote se adapte às necessidades específicas de cada projeto, facilitando o planejamento e gestão das operações de coleta de dados.","code":""},{"path":[]},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"caso-1--calculando-os-custos-da-coleta-da-munic","dir":"Articles","previous_headings":"Estudos de caso","what":"Caso 1. Calculando os custos da coleta da MUNIC","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Pesquisa de Informações Básicas Municipais (MUNIC) realizada pelo Instituto Brasileiro de Geografia e Estatística (IBGE) é uma pesquisa fundamental para coletar informações essenciais sobre os municípios em todo o Brasil. alocação eficiente dos municípios às agências IBGE responsáveis pela coleta de dados é um aspecto importante para o sucesso da pesquisa MUNIC, principalmente nas Unidades da Federação com maior número de agências e municípios. O processo envolve atribuir cada município à agência mais adequada, considerando fatores como proximidade geográfica, capacidade da agência e custos de viagem. complexidade dessa tarefa aumenta com o número de municípios e agências envolvidas, tornando alocação manual desafiadora e potencialmente levando atribuições abaixo ideal. Para enfrentar esse desafio, o pacote orce utiliza algoritmos avançados de otimização e incorpora vários fatores de custo para identificar estratégia de alocação mais eficiente, minimizando despesas de viagem, carga de trabalho da equipe e custos gerais da pesquisa. Vamos começar Superintendência Estadual Espírito Santo, que tem um número relativamente pequeno municípios e agências, facilitando exposição processo de estimação. Espírito Santo tem 78 municípios, e 10 agências IBGE.  Vamos supor que seja necessário visitar todos os 78 municípios. Como podemos estimar o custo da coleta? Partiremos de algumas premissas. Municípios na mesma microrregião ou região metropolitana não pagam diária, não ser que seja exigida pernoite. Quando o tempo de viagem é maior que horas, paga-se diária, mesmo se na jurisdição da agência. coleta presencial dura 2 dias. Quando há pernoite, são pagas 1,5 diárias, e coleta é feita em 1 viagem(ns). Quando não há pernoite, são feitas 2 viagem(ns) (ida e volta). Há pagamento de meia-diária nos casos especificados item 1. viagens, feitas por veículos IBGE, tem origem nas agências e destino nos municípios de coleta. Os veículos fazem 10 quilômetros por litro, e o custo combustível é de por litro. Importante: o consumo de combustível pode ser reduzido significativamente fazendo “roteiros”, em que uma viagem percorre mais de um município. Vamos ignorar, por enquanto, essa possibilidade. Diárias são calculadas para apenas um funcionário e tem o valor de 335. Os dados com unidades de coleta tem seguinte estrutura: Usamos como código da unidade de coleta (uc) o código IBGE município. Os dados devem ser únicos por uc. Dias de coleta (dias_coleta) e número de viagens (viagens) podem variar por município. Basta alterar aqui se o caso. Precisamos também da distância de cada agência para cada município, e se viagem paga diária quando não há pernoite. momento, estamos só analisando os municípios com respectivas agências de jurisdição, essa diária não é devida. Mas ao analisar alocações alternativas, é importante saber quando é que diárias são devidas. Essa informação está na tabela agencias_municipios_diaria, disponível pacote para todas unidades da federação. Precisamos também das distâncias, em quilômetros, entre cada agência e cada sede municipal (disponível em distancias_agencias_municipios_osrm), que combinamos com informações sobre diárias (agencias_municipios_diaria). Observação: coluna diaria_pernoite é calculada com base na duração da viagem (ida). partir de 1,5, são pagas diárias, mesmo se na jurisdição da agência. Estamos, agora, prontos para calcular os custos de coleta.","code":"map_uc_agencias(mnow%>%rename(uc_lat=municipio_sede_lat, uc_lon=municipio_sede_lon)) +   geom_point(aes(y=municipio_sede_lat, x=municipio_sede_lon, color=agencia_nome_bdo), data=mnow, alpha=3/4)+   geom_point(aes(y=agencia_lat, x=agencia_lon, color=agencia_nome_bdo), data=mnow, shape=2, size=3) +    labs(x=\"\", y=\"\", color=\"\") ucs_now <- municipios_22%>%   sf::st_drop_geometry()%>%   filter(substr(municipio_codigo,1,2)==ufnow$uf_codigo)%>%   left_join(agencias_bdo_mun%>%select(agencia_codigo, municipio_codigo), by=\"municipio_codigo\")%>%   mutate(uc=municipio_codigo)%>%   ## com agências intramunicipais tem mais de uma agência associada a município   ## vamos deixar só a primeira (em ordem numérica)   group_by(municipio_codigo)%>%   arrange(agencia_codigo)%>%   slice(1)%>%   mutate(viagens=params_se$viagens, dias_coleta=params_se$dias_coleta)  #library(tictoc) #tic() gt1(ucs_now%>%          head(10)%>%          ungroup%>%          select(uc=municipio_codigo, agencia_codigo, dias_coleta, viagens)) agencias_municipios_diaria%>%   semi_join(ucs_now, by=\"municipio_codigo\")%>%   head(10)%>%gt1() distancias_ucs <- distancias_agencias_municipios_osrm%>%                     left_join(agencias_municipios_diaria_now,                               by = join_by(agencia_codigo, municipio_codigo))%>%                     mutate(uc=municipio_codigo)%>%   semi_join(ucs_now, by=\"uc\")%>%   mutate(diaria_pernoite=duracao_horas>params_se$horas_viagem_pernoite)  gt1(distancias_ucs%>%          head(10)%>%          select(agencia_codigo, uc, distancia_km,                                duracao_horas, diaria_municipio, diaria_pernoite)) args_alocar_ucs <- params_se[names(params_se)%>%intersect(args(alocar_ucs)%>%as.list%>%names())] params_se[names(params_se)%>%setdiff(args(alocar_ucs)%>%as.list%>%names())] #> $horas_viagem_pernoite #> [1] 1,5 #>  #> $viagens #> [1] 1 #>  #> $dias_coleta #> [1] 2 #>  #> $custo_fixo #> [1] 0 #>  #> $uf_sigla #> [1] \"ES\"  args_alocar_ucs$agencias <- agencias_now%>%mutate(dias_coleta_agencia_max=Inf) #args_alocar_ucs$distancias_agencias <- distancias_agencias args_alocar_ucs$distancias_ucs <- distancias_ucs args_alocar_ucs$ucs <- ucs_now args_alocar_ucs$resultado_completo <- TRUE res <- do.call(what = alocar_ucs,                args=args_alocar_ucs)"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"custos-por-agência","dir":"Articles","previous_headings":"Estudos de caso > Caso 1. Calculando os custos da coleta da MUNIC","what":"Custos por agência","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"","code":"j <- res$resultado_ucs_jurisdicao%>%   left_join(agencias_now%>%sf::st_drop_geometry(), by=\"agencia_codigo\")%>%   left_join(assistencias, by=\"agencia_codigo\")%>%   group_by(assistencia_nome, agencia_nome)%>%   mutate(municipios=1)%>%   summarise(across(c(municipios, total_diarias, custo_diarias, distancia_total_km, custo_combustivel), sum)) #> `summarise()` has grouped output by 'assistencia_nome'. You can override using #> the `.groups` argument. gt(j%>%ungroup, groupname_col = 'assistencia_nome', rowname_col='agencia_nome')%>%   gt::summary_rows(fns = list(fn='sum', label=\"Total da Assistência\"), fmt=~fmt_nums(.))%>%   fmt_nums()%>%   gt::cols_label_with(fn=\"nomear_colunas\")%>%   gt::grand_summary_rows(fns = list(fn='sum', label=\"Total da Superintendência\")                          , fmt = ~fmt_nums(.))%>%   print_gt() resultado_ucs <- bind_rows(   res$resultado_ucs_otimo%>%mutate(plano= \"otimo\"),   res$resultado_ucs_jurisdicao%>%mutate(plano= \"jurisdicao\"))%>%   group_by(uc)%>%   mutate(mudanca=length(unique(agencia_codigo))>1) toexport <- res$resultado_ucs_jurisdicao%>%   rename(municipio_codigo=uc)%>%   left_join(agencias_now%>%sf::st_drop_geometry(), by = join_by(agencia_codigo))%>%   left_join(municipios_22%>%select(municipio_codigo, municipio_nome), by = join_by(municipio_codigo))%>%   left_join(assistencias, by = join_by(agencia_codigo))%>%   transmute(     assistencia_nome,     agencia_codigo, agencia_nome,     municipio_nome, municipio_codigo,             distancia_km, duracao_horas, diaria, meia_diaria, trechos, total_diarias, custo_diarias, distancia_total_km, custo_combustivel, custo_horas_viagem, custo_deslocamento)    export_dir <- file.path(here::here(\"vignettes\", \"articles\", \"munic\")) dir.create(export_dir, recursive = TRUE, showWarnings = FALSE) export_path <- file.path(export_dir,paste0(\"munic_\", ufnow$uf_codigo, \"_\", format(Sys.time(), \"%Y%m%d_%H\"), \".xlsx\")) toexport_l <- lapply(toexport%>%split(.$assistencia_nome), function(x) janitor::remove_constant(x)) #sigba::excel(toexport_l, filename = export_path)"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"custos-por-município","dir":"Articles","previous_headings":"Estudos de caso > Caso 1. Calculando os custos da coleta da MUNIC","what":"Custos por município","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"","code":"mnow%>%   left_join(res$resultado_ucs_jurisdicao, by=c(\"municipio_codigo\"=\"uc\", \"agencia_codigo\"))%>%   transmute(municipio_nome, agencia_nome=capitalizar(agencia_nome), custo_diarias, custo_combustivel)%>%   sf::st_drop_geometry()%>%   arrange(desc(custo_diarias+custo_combustivel))%>%   head(10)%>%   gt1()"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"lidando-com-contigências-da-coleta","dir":"Articles","previous_headings":"Estudos de caso > Caso 1. Calculando os custos da coleta da MUNIC","what":"Lidando com contigências da coleta","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Suponha agora que é necessário fazer uma visita ao município de Barra de São Francisco, mas agência de jurisdição não está disponível por qualquer motivo (férias, licença de saúde, veículo IBGE quebrado, etc.) Quais são agências alternativas para realizar essa coleta? função alocar_ucs retorna, opcionalmente, lista completa de combinações entre agências XX municípios, que permite facilmente responder essa pergunta. Nota-se que outras agências podem realizar coleta municípios, e qual custo.","code":"munnow <- municipios_22%>%filter(municipio_codigo=='3200904') res$ucs_agencias_todas%>%   semi_join(munnow, by=c(\"uc\"=\"municipio_codigo\"))%>%   left_join(agencias_now, by=\"agencia_codigo\")%>%   mutate(jurisdicao=agencia_codigo_jurisdicao==agencia_codigo)|>   transmute(agencia_nome=glue::glue(\"{agencia_nome} {if_else(jurisdicao, '(Jurisdição)', '')}\"), distancia_km, custo_diarias, custo_combustivel)%>%   arrange(custo_diarias+custo_combustivel)%>%   gt::gt()|>   print_gt()"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"otimizando-a-alocação-de-municípios","dir":"Articles","previous_headings":"Estudos de caso > Caso 1. Calculando os custos da coleta da MUNIC","what":"Otimizando a alocação de municípios","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"pergunta que segue, naturalmente, é, há algum município que teria custos de coleta menores se coleta fosse realizada por agência diferente da de jurisdição? resposta é sim! Sabemos que os custos com combustível e diárias estão longe de ser os únicos fatores para selecionar agência de coleta. própria troca de agência de coleta tem um custo não desprezível. Os funcionários da agência de jurisdição provavelmente conhecem melhor o município de coleta, e até na gerência da coleta (que agência mesmo coleta o município X?) coloca um custo não trivial. Outras possibilidade é distância em quilômetros ser menor, mas o tempo de viagem (por conta de qualidade da estrada, por exemplo) ser maior. O tempo gasto viajando certamente tem um custo para além das diárias e combustível. Propomos avaliar o custo de deslocamento como soma custo de diárias, combustível, e custo adicional por hora de viagem correspondente R$10. Além disso, só são propostas trocas que economizariam mínimo R$100 custo de deslocamento para o município.","code":"res$ucs_agencias_todas%>%   group_by(municipio_codigo=uc)%>%   mutate(custo_diaria_combustivel=custo_diarias+custo_combustivel)%>%   arrange(custo_diaria_combustivel)%>%   slice(1)%>%   filter(agencia_codigo_jurisdicao!=agencia_codigo)|>   left_join(agencias_now, by=\"agencia_codigo\")%>%   left_join(mnow%>%sf::st_drop_geometry()%>%select(municipio_codigo,municipio_nome))%>%   ungroup%>%   transmute(municipio_nome, agencia_nome, distancia_km, custo_diarias, custo_combustivel)%>%   arrange(custo_diarias+custo_combustivel)%>%   gt::gt()|>   print_gt() #> Joining with `by = join_by(municipio_codigo)` mudancas <- resultado_ucs%>%   filter(mudanca)%>%   left_join(agencias_now%>%select(agencia_codigo,                                    agencia_nome,                                   agencia_lat,                                   agencia_lon), by=\"agencia_codigo\")%>%   left_join(municipios_22%>%               sf::st_drop_geometry()%>%               select(uc=municipio_codigo, municipio_nome, municipio_sede_lat, municipio_sede_lon), by=\"uc\")%>%   mutate(uc_lat=municipio_sede_lat, uc_lon=municipio_sede_lon)%>%   ungroup()  if (nrow(mudancas)>0) {   gt(     mudancas%>%       select(agencia_nome, municipio_nome, distancia_km, custo_deslocamento, plano)%>%       tidyr::pivot_wider(names_from = c(\"plano\"), id_cols = c(\"municipio_nome\"), values_from=c(\"agencia_nome\", \"distancia_km\", \"custo_deslocamento\"))#%>%arrange(agencia_nome_otimo)   )%>%     gt::cols_label_with(fn=\"nomear_colunas\")|>     print_gt() } if (nrow(mudancas)>0) {  mudancas_l <- mudancas%>%group_split(municipio_nome)   for (i in seq_along(mudancas_l)) {     dnow <- mudancas_l[[i]]%>%       arrange(plano)%>%       mutate(title=glue::glue(\"{municipio_nome}:\\n.  de {agencia_nome[1]}\\n   para {agencia_nome[2]}\"),     subtitle=glue::glue(\"{agencia_nome}: {round(distancia_km)} km (R$ {round(custo_deslocamento)})\"))     p <- map_uc_agencias(dnow) +       geom_label(aes(x=municipio_sede_lon, y=municipio_sede_lat, label=municipio_nome), data=dnow[1,], size=3) +       geom_label(aes(x=agencia_lon, y=agencia_lat, label=agencia_nome), data=dnow, size=3) +     theme_minimal() +       labs(title = dnow$title[1], caption = paste(dnow$subtitle, collapse='\\n'), x=\"\",y=\"\")+       guides(color=\"none\")     print(p)   } }"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"resumo-da-otimização","dir":"Articles","previous_headings":"Estudos de caso > Caso 1. Calculando os custos da coleta da MUNIC","what":"Resumo da otimização","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Utilizando o plano otimizado, com 4 alterações de agência de coleta, é possível economizar 8% valor das diárias, gastando apenas 0% mais em combustível.","code":"resultado_ucs%>%   transmute(agencia_codigo, custo_diarias, custo_combustivel, custo_horas_viagem, total=custo_deslocamento, plano)%>%   group_by(plano)%>%   summarise(across(where(is.numeric), sum), n_agencias=n_distinct(agencia_codigo))%>%   tidyr::pivot_longer(cols=-plano)%>%   tidyr::pivot_wider(names_from=plano)%>%   mutate(reducao=jurisdicao-otimo,          reducao_pct=1-otimo/jurisdicao) -> resumo_planos resumo_planos%>%   gt::gt()%>%   print_gt() economia_diarias <- resumo_planos%>%filter(name==\"custo_diarias\")%>%pull(reducao_pct) economia_combustivel <- resumo_planos%>%filter(name==\"custo_combustivel\")%>%pull(reducao_pct) if (economia_combustivel > 0) { economia_combustivel_str <-   glue::glue(\"{round(economia_combustivel*100,1)}% a **menos**\") } else {   economia_combustivel_str <-  glue::glue(\"apenas {-round(economia_combustivel*100,1)}% a mais\") } # conds <- tidyr::expand_grid(dist_diaria_km=c(50,75,125), adicional_troca_jurisdicao=c(0,333,999)) # res_conds <- purrr::pmap(conds, function(dist_diaria_km, adicional_troca_jurisdicao) { #   alocar_ucs(ucs=ucs_now,  #                   agencias=agencias_now,  #                   ## treinamento na agência #                   agencias_treinamento = '292740800',  #                   distancias_agencias = distancias_agencias,  #                   distancias_ucs =  #                     distancias_ucs,  #                   custo_fixo=0, #                   dias_treinamento=0, #                   dist_diaria_km = dist_diaria_km, #                   adicional_troca_jurisdicao = adicional_troca_jurisdicao) # }, .progress = TRUE) ufs_sem_missing_dist <- distancias_agencias_municipios_osrm%>%   group_by(uf_codigo=substr(agencia_codigo,1,2))%>%   filter(all(!is.na(distancia_km)))%>%   distinct(uf_codigo)%>%   pull(uf_codigo)%>%sort() ufs_sem_missing_dist <- ufs_sem_missing_dist[ufs_sem_missing_dist!=53]"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"resultados-para-outras-superintendências-estaduais","dir":"Articles","previous_headings":"Estudos de caso > Caso 1. Calculando os custos da coleta da MUNIC","what":"Resultados para outras Superintendências Estaduais1","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"","code":"filter_uf <- function(x) {   x%>%     filter(substr(agencia_codigo,1,2)==ufnow$uf_codigo,             !agencia_codigo%in%c(\"130420300\",\"130140700\"),            !municipio_codigo%in%c(\"1300300\", \"1301001\", \"1301407\", \"1301951\", \"1303106\", \"1304203\")) }   res_ufs <- vector(mode = \"list\", length = length(ufs_sem_missing_dist)) names(res_ufs) <- as.character(ufs_sem_missing_dist) for (uf_codigo_now in ufs_sem_missing_dist) {   params_uf <- params   ufnow <- ufs%>%filter(uf_codigo==uf_codigo_now)   distancias_ucs <- distancias_agencias_municipios_osrm%>%     left_join(agencias_municipios_diaria_now,               by = join_by(agencia_codigo, municipio_codigo))%>%     mutate(uc=municipio_codigo)%>%     filter_uf()   stopifnot(nrow(distancias_ucs%>%filter(is.na(distancia_km)))==0)      ucs_now <- distancias_ucs%>%     distinct(municipio_codigo)%>%     left_join(agencias_bdo_mun%>%select(agencia_codigo, municipio_codigo), by=\"municipio_codigo\")%>%     mutate(uc=municipio_codigo)%>%     ## com agências intramunicipais tem mais de uma agência associada a município     ## vamos deixar só a primeira (em ordem numérica)     group_by(municipio_codigo)%>%     arrange(agencia_codigo)%>%     slice(1)%>%     mutate(viagens=params_se$viagens, dias_coleta=params_se$dias_coleta)%>%     filter_uf()      cnames <- names(params_uf)%>%intersect(args(alocar_ucs)%>%as.list%>%names())   args_alocar_ucs <- params_uf[cnames]   args_alocar_ucs$agencias <- NULL   args_alocar_ucs$distancias_ucs <- distancias_ucs%>%mutate(diaria_pernoite=duracao_horas>params_se$horas_viagem_pernoite)   args_alocar_ucs$ucs <- ucs_now   args_alocar_ucs$resultado_completo <- FALSE   #args_alocar_ucs$rel_tol <- .02   #args_alocar_ucs$max_time <- 60*30   res <- do.call(what = alocar_ucs,                   args=args_alocar_ucs)      resultado_ucs <- bind_rows(     res$resultado_ucs_otimo%>%mutate(plano= \"otimo\"),     res$resultado_ucs_jurisdicao%>%mutate(plano= \"jurisdicao\"))%>%     group_by(uc)%>%     mutate(mudanca=length(unique(agencia_codigo))>1)          resultado_ucs%>%     transmute(agencia_codigo, custo_diarias, custo_combustivel, custo_horas_viagem, total=custo_deslocamento, plano)%>%     group_by(plano)%>%     summarise(across(where(is.numeric), sum), n_agencias=n_distinct(agencia_codigo))%>%     tidyr::pivot_longer(cols=-plano)%>%     tidyr::pivot_wider(names_from=plano)%>%     mutate(reducao=jurisdicao-otimo,            reducao_pct=1-otimo/jurisdicao,uf_codigo=uf_codigo_now) -> resumo_planos   res_ufs[[as.character(uf_codigo_now)]] <- resumo_planos }  res_ufs_df <- bind_rows(res_ufs)%>%filter(name==\"total\")%>%left_join(ufs, by=\"uf_codigo\")  res_ufs_df%>%   ungroup%>%   select(regiao_nome, uf_nome, jurisdicao, otimo, reducao, reducao_pct)%>%   arrange(regiao_nome, desc(reducao))%>%   group_by(regiao_nome)%>%   gt()%>%   gt::summary_rows(fns=list(fn=\"sum\", label=\"Total da Região\"), columns = c(\"jurisdicao\", \"otimo\", \"reducao\"), fmt = ~fmt_nums(.x, decimal_num = 0))%>%   gt::grand_summary_rows(fns=list(fn='sum', label=\"Total Brasil\"), columns = c(\"jurisdicao\", \"otimo\", \"reducao\"),fmt = ~fmt_nums(.x, decimal_num = 0))%>%   gt::cols_label(uf_nome=\"\", jurisdicao=\"Jurisdição (R$)\", otimo=\"Ótimo (R$)\", reducao=\"Redução (R$)\", reducao_pct=\"Redução (%)\")%>%   print_gt(decimal_num=0) # ggplot(data = res_ufs_df%>%mutate(uf_nome=forcats::fct_reorder(uf_nome, reducao)), aes(x=reducao, y=uf_nome)) + #   geom_point() + #   scale_x_continuous(labels=scales::label_currency(prefix = \"R$ \", decimal.mark = \",\", big.mark = \".\")) + #   labs(subtitle=\"Redução total nos custos de descolamento do plano ótimo\\nem comparação com a manutenção das agência de jurisdição\", x=\"\", y=\"\")"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"caso-2--a-importância-dos-custos-fixos-salário-e-treinamento-calculando-os-custos-da-coleta-da-pof-para-a-superintendência-estadua-da-bahia-sesba","dir":"Articles","previous_headings":"Estudos de caso","what":"Caso 2. A importância dos custos fixos (salário e treinamento): calculando os custos da coleta da POF para a Superintendência Estadua da Bahia (SES/BA)","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Redução de custos promovido pela otimização da rede de coleta tabela demonstra o impacto da otimização da rede de coleta em diferentes cenários, considerando custos fixos, diárias, combustível e número de agências envolvidas2. Principais Observações: Em todos os cenários, otimização resultou em redução significativa custo total. Realocação de UPAs entre agências: Outras medidas também tem seu impacto. redistribuição ótima de UPAs entre agências, sem alteração número de agências na coleta, tem o não desprezível impacto de R$ 18 mil. Custo de treinamento: Se incluímos os custos de treinamento (2 funcionários por agência) o número de agência ótimo diminui bastante (cerca de 30%), e o valor economizado salta para cerca de R$ 50 mil. O custo de deslocamento (combustível e diárias) aumenta após otimização. Isso é explicado pela necessidade de percorrer distâncias maiores para cobrir UCs com uma rede menor de agências. entanto, esse aumento é mais que compensado pela redução dos custos fixos, resultando em uma economia geral. Reorganização da Jurisdição: reorganização da jurisdição das agências também pode levar uma redução de custos. Por exemplo, quando incluímos o custo de treinamento e reorganizamos jurisdição das agências de modo minimizar o pagamento de diárias, economia salta de R$ 50 mil para R$ 65 mil. Limite de UPAs por Agência: imposição de um limite de 24 UPAs por agência contribui para um melhor balanceamento da carga de trabalho, evitando sobrecarga em algumas agências. O impacto dessa restrição na economia prevista é razoavelmente pequeno nos casos analisados. Redução de Custos de Pessoal: Quando incluímos despesa com somente um entrevistador adicional por agência, além de treinamento para dois funcionários, economia gerada passa de R$ 500 mil. É definitivamente aqui que está o mais efetivo instrumento para reduzir os custos de coleta.","code":"uf_codigo_now <- 29 ufnow <- ufs%>%filter(uf_codigo==uf_codigo_now) ## amostra_pof load(file.path(pof2024ba:::package$cache_dir, \"amostra_preliminar.rda\"))  amostra_uf <- amostra_preliminar%>%   filter(substr(upa,1,2)==ufnow$uf_codigo)%>%   #filter(!grepl(\"^2927408\" ,agencia_codigo))%>%   distinct(upa, .keep_all = TRUE)%>%   rename(uc=upa)%>%   mutate(     dias_coleta = 10,     viagens = 2)#%>%ungroup()%>%slice_sample(n=100)  ## distancias upas distancias_upas <- readRDS(\"/Users/eleon/gitlab/orce/data-raw/distancias_agencias_setores_osrm.rds\")%>%   rename(uc=setor)%>%   mutate(municipio_codigo=substr(uc,1,7))%>%   left_join(agencias_municipios_diaria, by=c(\"agencia_codigo\", \"municipio_codigo\"))%>%   semi_join(amostra_uf, by=\"uc\")%>%   mutate(diaria_pernoite=duracao_horas>1.5) ## sem custo fixo nem custo de treinamento params_pof_0  <- list(ucs=amostra_uf,            custo_litro_combustivel = 6,            custo_hora_viagem = 10,            kml = 10,            valor_diaria = 335,            dias_treinamento = 0,            agencias_treinadas = NULL,            agencias_treinamento  = NULL,            distancias_ucs=distancias_upas,            adicional_troca_jurisdicao  = 0,            remuneracao_entrevistador=0,            n_entrevistadores_min=2,             dias_coleta_entrevistador=200,            solver=params$solver,            max_time=params$max_time,            rel_tol=params$rel_tol            ## for symphony solver            #solver=\"symphony\",            #gap_limit=2,            #max_time=10*60,            )  dagencias <- distancias_agencias_osrm params_pof_1 <- modifyList(params_pof_0,                             list(                              distancias_agencias=distancias_agencias_osrm,                              dias_treinamento = 5.5,# por funcionário                              agencias_treinamento  = c('292740800', '291080000')))  estrategias_pof <- bind_rows(   tibble(params=list(params_pof_0),           descricao='sem custo fixo / sem custo de treinamento'),   tibble(params=list(params_pof_1), descricao=\"com treinamento\"),   tibble(params=list(modifyList(params_pof_1,                                 ## simulando quando não há diária por conta do município (somente por pernoite)                                 list(distancias_ucs=distancias_upas%>%                                   mutate(diaria_municipio=FALSE)))),           descricao=\"custo de treinamento / reorganização\"),   tibble(params=list(modifyList(params_pof_1,                                  list(                                   ## diárias só com mais de duas horas de viagem                                   distancias_ucs=distancias_upas%>%                                     mutate(diaria_pernoite=duracao_horas>2)))),           descricao=\"custo de treinamento / redução diárias por pernoite\"),   tibble(params=list(modifyList(params_pof_1,                                  list(remuneracao_entrevistador=1500*12))), descricao='custo de treinamento + salario de apms'),   tibble(params=list(modifyList(params_pof_1,                                  list(                                   adicional_troca_jurisdicao=300))),           descricao='custo de treinamento  / adicional_troca_jurisdicao'))%>%   mutate(resultado=purrr::map(params, ~do.call(alocar_ucs, .x), .progress = TRUE))    estrategias_pof_sum <-    estrategias_pof%>%   rowwise(descricao)%>%   reframe(     bind_rows(       resultado$resultado_agencias_otimo%>%mutate(modelo=\"Ótimo\"),       resultado$resultado_agencias_jurisdicao%>%mutate(modelo=\"Jurisdição\"))%>%       group_by(modelo)%>%       mutate(n_agencias=1)%>%       summarise(across(matches(\"custo|n_agencias\"), ~sum(.x, na.rm=TRUE))))%>%   mutate(custo_total=custo_deslocamento+custo_fixo+custo_total_entrevistadores)%>%   select(descricao, modelo, n_agencias, custo_total, everything())  estrategias_pof_sum%>%   group_by(descricao)%>%   arrange(modelo)%>%   select(-modelo)%>%summarise(across(everything(), diff))%>%   select(descricao, n_agencias, custo_total, custo_total_entrevistadores, custo_diarias, custo_combustivel)%>%   arrange(-custo_total)%>%   gt::gt()%>%   gt::cols_label(descricao='Modelo')%>%   gt::tab_caption(\"Redução de custos promovido pela otimização da rede de coleta\")%>%   print_gt()"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"caso-3--um-novo-modelo-de-coleta-nas-agências","dir":"Articles","previous_headings":"Estudos de caso","what":"Caso 3. Um novo modelo de coleta nas Agências","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Redução de custos promovido pela otimização da rede de coleta","code":"## amostra mestra/pnadc amostra_mestra <- readr::read_rds(here::here(\"data-raw/amostra_br_2024_01_2025_06.rds\"))%>%   filter(ano_mes>=as.Date(\"2024-07-01\"), ano_mes<=as.Date(\"2025-06-01\"))  amostra_pnadc <- amostra_mestra%>%   distinct(uc=upa, pesquisa=paste(\"pnadc\", substr(ano_mes,1,7)), agencia_codigo, dias_coleta=5, viagens=1)  amostra_cnefe <- amostra_mestra%>%   filter(entrevista_numero==1)%>%   mutate(ano_mes=ano_mes-months(3))%>%   distinct(uc=upa, pesquisa=paste(\"cnefe\", substr(ano_mes,1,7)), agencia_codigo, dias_coleta=5, viagens=1)  ## amostra pof load(file.path(pof2024ba:::package$cache_dir, \"amostra_preliminar.rda\")) amostra_pof <- amostra_preliminar%>%   distinct(uc=upa, pesquisa=paste(\"pof\", if_else(trimestre==1, 2024, 2025), if_else(trimestre==1, 4, trimestre-1)), agencia_codigo=as.character(agencia_codigo), dias_coleta=10, viagens=2)  ## municipais municipais <- municipios_22%>%   sf::st_drop_geometry()%>%   left_join(agencias_bdo_mun%>%select(agencia_codigo, municipio_codigo), by=\"municipio_codigo\")%>%   mutate(uc=municipio_codigo)%>%   ## com agências intramunicipais tem mais de uma agência associada a município   ## vamos deixar só a primeira (em ordem numérica)   group_by(municipio_codigo)%>%   arrange(agencia_codigo)%>%   slice(1)%>%   ungroup()%>%   distinct(uc, pesquisa=\"municipais\", agencia_codigo, viagens=2, dias_coleta=3)   carga_br <- bind_rows(amostra_cnefe, amostra_pnadc, amostra_pof, municipais)%>%   group_by(uc, agencia_codigo, municipio_codigo=substr(uc,1,7))%>%   summarise(dias_coleta=sum(dias_coleta), viagens=sum(viagens)) #> `summarise()` has grouped output by 'uc', 'agencia_codigo'. You can override #> using the `.groups` argument.   uf_codigo_now <- 29 ufnow <- ufs%>%filter(uf_codigo==uf_codigo_now)  carga_uf <- carga_br%>%   filter(substr(uc,1,2)==ufnow$uf_codigo)%>%   ## Importante: Sem as agências de Salvador   filter(!grepl(\"2927408\", agencia_codigo))%>%   #ungroup#%>%filter(agencia_codigo%in%c(\"291360600\", \"291480200\", \"292870300\", \"293290300\", \"290490200\", \"292740800\", \"292740801\", \"291640100\"))   ungroup#%>%filter(agencia_codigo%in%unique(agencia_codigo)[1:20])  ## distancias uc distancias_ucs_all <- readRDS(\"/Users/eleon/gitlab/orce/data-raw/distancias_agencias_setores_osrm.rds\")%>%   rename(uc=setor)%>%   bind_rows(distancias_agencias_municipios_osrm%>%rename(uc=municipio_codigo))%>%   transmute(uc, agencia_codigo, distancia_km, duracao_horas, municipio_codigo=substr(uc,1,7))%>%   left_join(agencias_municipios_diaria, by=c(\"agencia_codigo\", \"municipio_codigo\"))%>%   semi_join(carga_uf, by=\"uc\")%>%   mutate(diaria_pernoite=duracao_horas>1.5)   agencias_uf <-  carga_uf%>%   group_by(agencia_codigo)%>%   summarise(n_ucs_jurisdicao=n(), dias_coleta_jurisdicao=sum(dias_coleta))%>%   mutate(uc_agencia_max=Inf, dias_coleta_agencia_max=pmax(dias_coleta_jurisdicao, 600), custo_fixo=0)   ## sem custo fixo nem custo de treinamento params_carga_0  <- list(ucs=carga_uf,                         agencias=agencias_uf,                         custo_litro_combustivel = 6,                         custo_hora_viagem = params$custo_hora_viagem,                         kml = params$kml,                         valor_diaria = params$valor_diaria,                         ## em um ano de coleta, um entrevistador consegue                         ## 48 upas pnadc / 24 upas POF / 18 Municipios                         dias_coleta_entrevistador_max=200,                         diarias_entrevistador_max=Inf,                         dias_treinamento = 0,                         agencias_treinadas = NULL,                         agencias_treinamento  = NULL,                         distancias_ucs=distancias_ucs_all,                         ## for symphony solver                         #gap_limit=5,                          adicional_troca_jurisdicao  = params$adicional_troca_jurisdicao,                         solver=params$solver,                         max_time=params$max_time,                         rel_tol=params$rel_tol,                         resultado_completo=FALSE                          )  library(tictoc) tic() estrategias_carga <- bind_rows(   tibble(params=list(params_carga_0),           descricao='sem custo fixo / sem custo de treinamento'),   tibble(params=list(modifyList(params_carga_0,                                  list(                                   agencias=agencias_uf%>%                                   mutate(                                   custo_fixo=10000*12),                                   n_entrevistadores_min=2,                                   remuneracao_entrevistador=12*1500,                                   max_time=max(params$max_time, 60*60)                                   #max_time=                                 ))),           descricao='remuneracao apm 1500 p/mes/2 Técnicos 10000 p/ mes custo fixo, n_entrevistadores_min=2'),     tibble(params=list(modifyList(params_carga_0,                                  list(                                   distancias_ucs=params_carga_0$distancias_ucs%>%                                     mutate(diaria_municipio=FALSE),                                   agencias=agencias_uf%>%                                   mutate(                                   custo_fixo=10000*12),                                   n_entrevistadores_min=2,                                   remuneracao_entrevistador=12*1500                                 ))),           descricao='remuneracao apm 1500 p/mes/2 Técnicos 10000 p/ mes custo fixo, n_entrevistadores_min=2, reorganizacao jurisdicao'),   tibble(params=list(modifyList(params_carga_0,                                  list(                                   valor_diaria=params$valor_diaria*2,                                   distancias_ucs=params_carga_0$distancias_ucs,                                   agencias=agencias_uf%>%                                   mutate(                                   custo_fixo=10000*12),                                   n_entrevistadores_min=2,                                   remuneracao_entrevistador=12*1500                                 ))),           descricao='remuneracao apm 1500 p/mes/2 Técnicos 10000 p/ mes custo fixo, n_entrevistadores_min=2, custo diaria 2x') )%>%   #head(4)%>%   mutate(resultado=purrr::map(params, ~do.call(alocar_municipios, .x))) toc() #> 0,051 sec elapsed  estrategias_carga_sum <-    estrategias_carga%>%   rowwise(descricao)%>%   reframe(     bind_rows(       resultado$resultado_agencias_otimo%>%mutate(modelo=\"Ótimo\"),       resultado$resultado_agencias_jurisdicao%>%mutate(modelo=\"Jurisdição\"))%>%       group_by(modelo)%>%       mutate(n_agencias=1)%>%       summarise(across(matches(\"custo|n_agencias\"), ~sum(.x, na.rm=TRUE))))%>%   mutate(custo_total=custo_deslocamento+custo_fixo+custo_total_entrevistadores)%>%   select(descricao, modelo, n_agencias, custo_total, everything()) #report_plans(estrategias_carga$resultado[[1]])  estrategias_carga_sum%>%   group_by(descricao)%>%   arrange(descricao, modelo)%>%   select(-modelo)%>%   summarise(across(everything(), diff))%>%   select(descricao, n_agencias, custo_total, custo_total_entrevistadores, custo_diarias, custo_combustivel)%>%   #arrange(-custo_total)%>%   gt::gt()%>%   gt::cols_label(descricao='Modelo')%>%   gt::tab_caption(\"Redução de custos promovido pela otimização da rede de coleta\")%>%   print_gt()"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"conclusão","dir":"Articles","previous_headings":"Estudos de caso","what":"Conclusão","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"otimização da rede de coleta promovida pelo pacote orce tem um impacto significativo na redução de custos, principalmente pela diminuição dos custos fixos associados às agências. estratégia mais eficaz envolve combinação da redução número de agências, imposição de limites de UPAs por agência e reorganização da jurisdição, e é provavelmente vantajoso (impor o limite) para boa gestão da coleta. É importante ressaltar que otimização deve considerar não apenas os custos, mas também outros fatores como qualidade dos dados coletados e capacidade operacional das agências. O pacote orce oferece flexibilidade para ajustar os parâmetros e restrições modelo, permitindo encontrar solução que melhor se adapta às necessidades e particularidades de cada pesquisa.","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"apêndice-detalhes-técnicos-do-problema-de-otimização","dir":"Articles","previous_headings":"Estudos de caso","what":"Apêndice: Detalhes técnicos do problema de otimização","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Este apêndice detalha o problema de otimização que o pacote orce resolve, que é alocação ideal de Unidades de Coleta (UCs) às agências, com o objetivo de minimizar os custos totais, incluindo custos de deslocamento e custos fixos de cada agência. O modelo de otimização é baseado problema clássico de localização de armazéns, e é baseado em “Warehouse Location Problem”, de Dirk Schumacher.","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"o-desafio","dir":"Articles","previous_headings":"Estudos de caso > Apêndice: Detalhes técnicos do problema de otimização","what":"O Desafio","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Dadas localizações das UCs e das agências, tarefa é decidir quais agências serão utilizadas e como UPAs serão distribuídas entre elas. Em outras palavras, precisamos decidir simultaneamente: Quais agências treinar/contratar. Como alocar UC cada agência. Começamos com um conjunto de UCs U={1…n}U = \\{1 \\ldots n\\} e um conjunto de agências potenciais ={1…m}= \\{1 \\ldots m\\} que poderiam ser ativadas. Também temos uma função de custo que fornece o custo de viagem de uma agência para uma UC. Além disso, há um custo fixo (incluindo custos de treinamento, entre outros) associado cada agência, caso ela seja selecionada para coleta de dados. Agências com um pequeno número de UCs podem ser inviáveis. Agências interior com um grande número de UCs também podem ser inviáveis. solução deve ter pelo menos min_upas e máximo max_upas por agência ativada. Observe que, ao permitir coleta “semi-centralizada”, não há limite para o número de UCs nas agências listadas. Para modelar essa situação, usamos duas variáveis de decisão: xi,jx_{,j}: uma variável binária que assume o valor 1 se UC ii alocada à agência jj e 0 caso contrário. yjy_j: uma variável binária que assume o valor 1 se agência jj selecionada para realizar coleta e 0 caso contrário. $$ \\begin{array}{ll@{}ll} \\text{minimizar} & \\displaystyle\\sum\\limits_{=1}^{n}\\sum\\limits_{j=1}^{m} custo\\_de\\_viagem_{,j} \\cdot x_{, j} + \\sum\\limits_{j=1}^{m} custo\\_fixo_{j} \\cdot y_{j}& &\\\\ \\text{sujeito } & \\displaystyle\\sum\\limits_{j=1}^{m} x_{, j} = 1 & =1 ,\\ldots, n&\\\\ & \\displaystyle x_{, j} \\leq y_j, & =1 ,\\ldots, n & j=1 ,\\ldots, m\\\\ & x_{,j} \\\\{0,1\\} &=1 ,\\ldots, n, & j=1 ,\\ldots, m \\\\ & y_{j} \\\\{0,1\\} &j=1 ,\\ldots, m& \\\\ & \\operatorname{(opcional)} \\sum\\limits_{=1}^{n}{x}_{,j} >= ( \\operatorname{min\\_upas} \\cdot y_{j}) & j=1 ,\\ldots, m& \\\\ & \\operatorname{(opcional)} \\sum\\limits_{=1}^{n}{x}_{,j} <= \\operatorname{max\\_upas}_{j} & j=1 ,\\ldots, m& \\end{array} $$ Explicação: Função Objetivo: Minimizar o custo total, que é soma dos custos de viagem para cada UC alocada uma agência e dos custos fixos de cada agência ativada. Cada UC deve ser alocada exatamente uma agência. Uma agência só pode receber UCs se estiver ativa. Opcional: Cada agência ativada deve ter pelo menos min_upas UCs alocadas. Opcional: Cada agência ativada deve ter máximo max_upas UCs alocadas. Variáveis de Decisão: x[, j]: Indica se UC é alocada à agência j (1 se sim, 0 se não). y[j]: Indica se agência j está ativa (1 se sim, 0 se não). Este modelo matemático representa o problema de alocação ótima e é resolvido pelo pacote orce para encontrar solução que minimiza os custos totais, considerando restrições e os custos específicos de cada cenário.","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"apêndice-função-principal-alocar_ucs","dir":"Articles","previous_headings":"Estudos de caso","what":"Apêndice: Função principal: alocar_ucs","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"função alocar_ucs realiza alocação otimizada de Unidades de Coleta (UCs) às agências, buscando minimizar os custos totais de deslocamento e operação. O processo de otimização considera diversas variáveis e restrições para encontrar solução mais eficiente. Entradas da Função uc: código único da UC agencia_codigo: código da agência à qual UC está atualmente alocada dias_coleta: número de dias de coleta na UC viagens: número de viagens necessárias para coleta na UC agencia_codigo: código único da agência custo_litro_combustivel: custo combustível por litro custo_hora_viagem: custo por hora de viagem kml: consumo médio de combustível veículo (km/l) valor_diaria: valor da diária custo_fixo: custo fixo mensal da agência dias_treinamento: número de dias/diárias para treinamento adicional_troca_jurisdicao: custo adicional por troca de jurisdição min_uc_agencia: número mínimo de UCs por agência (exceto agências treinadas) max_uc_agencia: número máximo de UCs por agência semi_centralizada: vetor com códigos de agências sem limite máximo de UCs agencias_treinadas: vetor com códigos de agências já treinadas (sem custo de treinamento) agencias_treinamento: código da(s) agência(s) de treinamento distancias_ucs: distâncias entre UCs e agências, contendo: uc, agencia_codigo, duracao_horas, diaria_municipio, diaria_pernoite distancias_agencias: distâncias entre agências resultado_completo: se TRUE, retorna informações adicionais sobre todas combinações de UCs e agências Processamento Interno Verifica se os argumentos de entrada são válidos Define o número máximo de UCs por agência, se não fornecido Cria alocação por jurisdição (se agencias não fornecido, assume agências das UCs) Seleciona agência de treinamento mais próxima para cada agência de coleta Calcula os custos de treinamento com base na distância e se agência já foi treinada Combina informações de UCs e agências em um formato adequado para otimização Calcula os custos de transporte (combustível, tempo de viagem, diárias) para cada combinação de UC e agência Utiliza o pacote ompr para criar um modelo de otimização x[, j]: 1 se UC alocada à agência j, 0 caso contrário y[j]: 1 se agência j incluída na solução, 0 caso contrário Define função objetivo: minimizar o custo total (deslocamento + custos fixos das agências + custos de treinamento) Cada UC deve ser alocada exatamente uma agência Se uma UC é alocada uma agência, agência deve estar ativa Restrições de número mínimo e máximo de UCs por agência (se aplicável) Resolve o modelo usando o solver GLPK Extrai solução ótima: quais UCs são alocadas quais agências Cria tabelas com os resultados da alocação ótima e da alocação original (por jurisdição), tanto para UCs quanto para agências Se resultado_completo TRUE, retorna também um tibble com todas combinações de UCs e agências e seus respectivos custos Saídas da Função resultado_ucs_otimo: alocação ótima das UCs e seus custos resultado_ucs_jurisdicao: alocação original das UCs e seus custos resultado_agencias_otimo: alocação ótima das agências, custos e número de UCs alocadas resultado_agencias_jurisdicao: alocação original das agências, custos e número de UCs alocadas ucs_agencias_todas (opcional): todas combinações de UCs e agências e seus custos Observações O cálculo de diárias já considera jurisdição, microrregiões, áreas metropolitanas e distância/necessidade de pernoite. flexibilidade pacote permite ajustar os parâmetros e restrições para atender às necessidades específicas planejamento da coleta de dados.","code":""},{"path":"https://leoniedu.github.io/orce/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Eduardo Leoni. Author, maintainer.","code":""},{"path":"https://leoniedu.github.io/orce/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Leoni E (2024). orce: Package (One Line, Title Case). R package version 0.0.0.9000, https://leoniedu.github.io/orce/.","code":"@Manual{,   title = {orce: What the Package Does (One Line, Title Case)},   author = {Eduardo Leoni},   year = {2024},   note = {R package version 0.0.0.9000},   url = {https://leoniedu.github.io/orce/}, }"},{"path":[]},{"path":"https://leoniedu.github.io/orce/index.html","id":"english","dir":"","previous_headings":"","what":"English","title":"What the Package Does (One Line, Title Case)","text":"orce package R package designed optimize allocation primary sampling units (PSUs), census tracts health facilities, IBGE (Brazilian Institute Geography Statistics) agencies. allocation process crucial efficient cost-effective data collection large-scale surveys censuses. package addresses several challenges inherent process, including: Routing Geocoding: Determining optimal routes PSUs agencies requires accurate location data. orce package leverages CNEFE (National Register Addresses Statistical Purposes) database obtain precise coordinates PSU, prioritizing high-density areas within census tracts ensure accessibility representativeness. ponto_setor_densidade function aids identifying representative locations. Allocation Optimization: core orce package allocation optimization algorithm. employs mixed-integer linear programming minimize overall cost data collection, considering factors like travel distances, travel time, fixed agency costs. alocar_upas function implements optimization, allowing flexible constraints agency capacity location preferences. Cost Calculation: Accurately estimating cost data collection involves just distances travel time. orce package incorporates knowledge administrative boundaries determine whether “diárias” (travel allowances) applicable. nuanced cost calculation ensures optimization results reflect true financial implications different allocation scenarios. Flexibility Adaptability: orce package offers various customization options accommodate specific needs different surveys data collection efforts. Users can define parameters fuel costs, hourly travel costs, vehicle fuel efficiency, agency-specific constraints. summary, orce package provides powerful versatile solution optimizing allocation PSUs IBGE agencies. addressing challenges related routing, geocoding, allocation optimization, cost calculation, enables efficient cost-effective data collection strategies. flexibility adaptability make valuable tool wide range survey census operations Brazil.","code":""},{"path":"https://leoniedu.github.io/orce/index.html","id":"português","dir":"","previous_headings":"","what":"Português","title":"What the Package Does (One Line, Title Case)","text":"O pacote orce é um pacote R projetado para otimizar alocação de unidades primárias de amostragem (UPAs), como setores censitários ou estabelecimentos de saúde, às agências IBGE (Instituto Brasileiro de Geografia e Estatística). Esse processo de alocação é crucial para coleta de dados eficiente e econômica em pesquisas e censos de grande escala. O pacote aborda vários desafios inerentes esse processo, incluindo: Roteamento e Geocodificação: determinação das rotas ideais entre UPAs e agências requer dados de localização precisos. O pacote orce utiliza o banco de dados CNEFE (Cadastro Nacional de Endereços para Fins Estatísticos) para obter coordenadas precisas para cada UPA, priorizando áreas de alta densidade dentro dos setores censitários para garantir acessibilidade e representatividade. função ponto_setor_densidade auxilia na identificação desses locais representativos. Otimização da Alocação: O núcleo pacote orce é seu algoritmo de otimização de alocação. Ele emprega programação linear inteira mista para minimizar o custo total da coleta de dados, considerando fatores como distâncias de viagem, tempo de viagem e custos fixos das agências. função alocar_upas implementa essa otimização, permitindo restrições flexíveis na capacidade da agência e nas preferências de localização. Cálculo de Custos: Estimar com precisão o custo da coleta de dados envolve mais que apenas distâncias e tempo de viagem. O pacote orce incorpora o conhecimento das fronteiras administrativas para determinar se “diárias” (ajudas de custo para viagens) são aplicáveis. Esse cálculo de custo diferenciado garante que os resultados da otimização reflitam verdadeiras implicações financeiras de diferentes cenários de alocação. Flexibilidade e Adaptabilidade: O pacote orce oferece várias opções de personalização para acomodar necessidades específicas de diferentes pesquisas e esforços de coleta de dados. Os usuários podem definir parâmetros como custos de combustível, custos de viagem por hora, eficiência de combustível veículo e restrições específicas da agência. Em resumo, o pacote orce fornece uma solução poderosa e versátil para otimizar alocação de UPAs às agências IBGE. Ao abordar os desafios relacionados ao roteamento, geocodificação, otimização de alocação e cálculo de custos, ele permite estratégias de coleta de dados eficientes e econômicas. Sua flexibilidade e adaptabilidade o tornam uma ferramenta valiosa para uma ampla gama de operações de pesquisa e censo Brasil.","code":""},{"path":"https://leoniedu.github.io/orce/reference/ToTitleCasePT.html","id":null,"dir":"Reference","previous_headings":"","what":"Convertion to title case with lower case for some classes of words. — ToTitleCasePT","title":"Convertion to title case with lower case for some classes of words. — ToTitleCasePT","text":"written Portuguese, converting title case, usual keep title case words, like prepositions, conjunctions, articles kinds pronouns.  functions locates cases converts lower case. Based gist ToTitleCasePT https://gist.github.com/jjesusfilho/454192db8356eb9c486a02698338221a https://github.com/jjesusfilho","code":""},{"path":"https://leoniedu.github.io/orce/reference/ToTitleCasePT.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convertion to title case with lower case for some classes of words. — ToTitleCasePT","text":"","code":"ToTitleCasePT(string, ...)"},{"path":"https://leoniedu.github.io/orce/reference/ToTitleCasePT.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convertion to title case with lower case for some classes of words. — ToTitleCasePT","text":"string vector characters converted title case connector words (one-word prepositions conjunctions) articles (definite indefinite) pronouns lower case.","code":""},{"path":"https://leoniedu.github.io/orce/reference/ToTitleCasePT.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convertion to title case with lower case for some classes of words. — ToTitleCasePT","text":"vector characters dimension string","code":""},{"path":"https://leoniedu.github.io/orce/reference/ToTitleCasePT.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convertion to title case with lower case for some classes of words. — ToTitleCasePT","text":"current list words converted lower case : articles o(s), (s), um, uma(s), uns pronouns , mim, meu(s), minha(s) te, ti, teu(s), tua(s) lhe(s), seu(s), sua(s) nos, nosso()(s) vos, vosso()(s) prepositions, contractions combinations prepositions , ante, até, após, com, contra, de, desde, em, entre, para, perante, por, sem, sob, sobre, trás contractions à(s), ()(s), ()(s), pelo()(s), pro()(s) (informal language) combinations ao(s) conjunctions conforme, conquanto, contudo, durante, embora, enquanto, então, entretanto, exceto, logo, mas, nem, ou, ora, pois, porém, porque, porquanto, portanto, quando, quanto, que, se, senão, todavia list far complete exaustive, mainly due absence accidental prepositions conjuntions, words originally prepositions conjunctions, can play roles contexts, like, instance segundo, can mean either numeral second prepositional expression acording .","code":""},{"path":"https://leoniedu.github.io/orce/reference/add_coordinates.html","id":null,"dir":"Reference","previous_headings":"","what":"Add Coordinates to an sf Object — add_coordinates","title":"Add Coordinates to an sf Object — add_coordinates","text":"function extracts coordinates sf object's geometry adds new columns object.","code":""},{"path":"https://leoniedu.github.io/orce/reference/add_coordinates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add Coordinates to an sf Object — add_coordinates","text":"","code":"add_coordinates(sf_object, lon = \"lon\", lat = \"lat\")"},{"path":"https://leoniedu.github.io/orce/reference/add_coordinates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add Coordinates to an sf Object — add_coordinates","text":"sf_object sf object containing spatial features. lon string specifying name longitude column. Defaults \"lon\". lat string specifying name latitude column. Defaults \"lat\".","code":""},{"path":"https://leoniedu.github.io/orce/reference/add_coordinates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add Coordinates to an sf Object — add_coordinates","text":"sf object added coordinate columns.","code":""},{"path":"https://leoniedu.github.io/orce/reference/add_coordinates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add Coordinates to an sf Object — add_coordinates","text":"","code":"# Load necessary packages library(sf) #> Linking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE library(dplyr)  # Create a simple sf object points <- data.frame(   name = c(\"A\", \"B\"),   geometry = c(\"POINT(1 2)\", \"POINT(3 4)\") ) %>%   st_as_sf(wkt = \"geometry\")  # Add coordinates using default column names points_with_coords <- add_coordinates(points)  # Add coordinates using custom column names points_with_coords_custom <- add_coordinates(points, lon = \"longitude\", lat = \"latitude\")"},{"path":"https://leoniedu.github.io/orce/reference/alocar_municipios.html","id":null,"dir":"Reference","previous_headings":"","what":"Alocação Otimizada de Municípios a Agências — alocar_municipios","title":"Alocação Otimizada de Municípios a Agências — alocar_municipios","text":"Esta função realiza alocação otimizada de Municípios agências, com o objetivo de minimizar os custos totais de deslocamento e operação. alocação leva em consideração restrições de capacidade das agências, custos de deslocamento (combustível, tempo de viagem e diárias), custos fixos das agências, custos de treinamento e o número de entrevistadores necessários.","code":""},{"path":"https://leoniedu.github.io/orce/reference/alocar_municipios.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Alocação Otimizada de Municípios a Agências — alocar_municipios","text":"","code":"alocar_municipios(   ucs,   agencias = data.frame(agencia_codigo = unique(ucs$agencia_codigo),     dias_coleta_agencia_max = Inf, custo_fixo = 0),   custo_litro_combustivel = 6,   custo_hora_viagem = 10,   kml = 10,   valor_diaria = 335,   diarias_entrevistador_max = Inf,   remuneracao_entrevistador = 0,   n_entrevistadores_min = 1,   dias_coleta_entrevistador_max,   dias_treinamento = 0,   agencias_treinadas = NULL,   agencias_treinamento = NULL,   distancias_ucs,   distancias_agencias = NULL,   adicional_troca_jurisdicao = 0,   resultado_completo = FALSE,   solver = \"cbc\",   rel_tol = 0.02,   max_time = 30 * 60,   ... )"},{"path":"https://leoniedu.github.io/orce/reference/alocar_municipios.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Alocação Otimizada de Municípios a Agências — alocar_municipios","text":"ucs Uma data.frame contendo informações sobre UCs, incluindo: uc: Código único da UC. municipio_codigo: Código único município. agencia_codigo: Código da agência à qual UC está atualmente alocada. dias_coleta: Número de dias de coleta na UC. viagens: Número de viagens necessárias para coleta na UC. agencias Uma data.frame contendo informações sobre agências selecionáveis, incluindo: agencia_codigo: Código único da agência. custo_fixo: Custo fixo associado à agência. dias_coleta_agencia_max: Número máximo de dias de coleta que agência pode realizar. custo_litro_combustivel Custo combustível por litro (em R$). Padrão: 6. custo_hora_viagem Custo de cada hora de viagem (em R$). Padrão: 10. kml Consumo médio de combustível veículo (em km/l). Padrão: 10. valor_diaria Valor da diária para deslocamentos (em R$). Padrão: 335. diarias_entrevistador_max Máximo de diárias que um entrevistador pode receber período de referência. Padrão: Inf. remuneracao_entrevistador Remuneração por entrevistador para todo o período de referência. Padrão: 0. n_entrevistadores_min Número mínimo de entrevistadores por agência. Padrão: 1. dias_coleta_entrevistador_max Número de dias de coleta por entrevistador. dias_treinamento Número de dias/diárias para treinamento. Padrão: 0 (nenhum treinamento). agencias_treinadas (Opcional) Um vetor de caracteres com os códigos das agências que já foram treinadas e não terão custo de treinamento. Padrão: NULL. agencias_treinamento Código da(s) agência(s) onde o treinamento será realizado. distancias_ucs Uma data.frame com distâncias entre UCs e agências, incluindo: uc: Código da UC. municipio_codigo: Código município onde UC está localizada. agencia_codigo: Código da agência. distancia_km: Distância em quilômetros entre UC e agência. duracao_horas: Duração da viagem em horas entre UC e agência. diaria_municipio: Indica se é necessária uma diária para deslocamento entre UC e agência, considerando o município da UC. diaria_pernoite: Indica se é necessária uma diária com pernoite para deslocamento entre UC e agência. distancias_agencias Uma data.frame com distâncias entre agências, incluindo: agencia_codigo_orig: Código da agência de origem. agencia_codigo_dest: Código da agência de destino. distancia_km: Distância em quilômetros entre agência de origem e de destino. duracao_horas: Duração da viagem em horas entre agência de origem e de destino. adicional_troca_jurisdicao Custo adicional quando há troca de agência de coleta. Padrão: 0. resultado_completo (Opcional) Um valor lógico indicando se deve ser retornado um resultado mais completo, incluindo informações sobre todas combinações de UCs e agências. Padrão: FALSE. solver Qual ferramenta para solução modelo de otimização utilizar. Padrão: \"cbc\". Outras opções: \"glpk\", \"symphony\" (instalação manual). rel_tol Tolerância relativa para otimização. Valores menores levam soluções mais precisas, mas podem aumentar o tempo de execução. Padrão: 0.02 max_time Tempo máximo de execução (em segundos) permitido para o solver. Padrão: 30*60 (30 minutos) ... Opções adicionais para o solver. uc_agencia_min Número mínimo de UCs por agência que incluída. Padrão: 1","code":""},{"path":"https://leoniedu.github.io/orce/reference/alocar_municipios.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Alocação Otimizada de Municípios a Agências — alocar_municipios","text":"Uma lista contendo: resultado_municipios_jurisdicao: Um tibble com os municipios e suas alocações originais (jurisdição), incluindo custos de deslocamento. resultado_agencias_jurisdicao: Um tibble com agências e suas alocações originais (jurisdição), incluindo custos fixos, custos de deslocamento e número de UCs alocadas. resultado_municipios_otimo: Um tibble com os municípios e suas alocações otimizadas, incluindo custos de deslocamento. resultado_agencias_otimo: Um tibble com agências e suas alocações otimizadas, incluindo custos fixos, custos de deslocamento, número de UCs alocadas e número de entrevistadores. municipios_agencias_todas (opcional): Um tibble com todas combinações de municípios e agências, incluindo distâncias, custos e informações sobre diárias (retornado apenas se resultado_completo TRUE). otimizacao (opcional): O resultado completo da otimização (retornado apenas se resultado_completo TRUE).","code":""},{"path":"https://leoniedu.github.io/orce/reference/alocar_ucs.html","id":null,"dir":"Reference","previous_headings":"","what":"Alocação Otimizada de Unidades de Coleta (UCs) a Agências — alocar_ucs","title":"Alocação Otimizada de Unidades de Coleta (UCs) a Agências — alocar_ucs","text":"Esta função realiza alocação otimizada de Unidades de Coleta (UCs) agências, com o objetivo de minimizar os custos totais de deslocamento e operação. alocação leva em consideração restrições de capacidade das agências (em número de dias de coleta), custos de deslocamento (combustível, tempo de viagem e diárias), custos fixos das agências e custos de treinamento.","code":""},{"path":"https://leoniedu.github.io/orce/reference/alocar_ucs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Alocação Otimizada de Unidades de Coleta (UCs) a Agências — alocar_ucs","text":"","code":"alocar_ucs(   ucs,   agencias = data.frame(agencia_codigo = unique(ucs$agencia_codigo),     dias_coleta_agencia_max = Inf, custo_fixo = 0),   custo_litro_combustivel = 6,   custo_hora_viagem = 10,   kml = 10,   valor_diaria = 335,   diarias_entrevistador_max = Inf,   remuneracao_entrevistador = 0,   n_entrevistadores_min = 1,   dias_coleta_entrevistador_max,   dias_treinamento = 0,   agencias_treinadas = NULL,   agencias_treinamento = NULL,   distancias_ucs,   distancias_agencias = NULL,   adicional_troca_jurisdicao = 0,   resultado_completo = FALSE,   solver = \"cbc\",   rel_tol = 0.02,   max_time = 30 * 60,   ... )"},{"path":"https://leoniedu.github.io/orce/reference/alocar_ucs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Alocação Otimizada de Unidades de Coleta (UCs) a Agências — alocar_ucs","text":"ucs Um tibble ou data.frame contendo informações sobre UCs, incluindo: uc: Código único da UC. agencia_codigo: Código da agência à qual UC está atualmente alocada. dias_coleta: Número de dias de coleta na UC. viagens: Número de viagens necessárias para coleta na UC. agencias Um tibble ou data.frame contendo informações sobre agências selecionáveis, incluindo: agencia_codigo: Código único da agência. dias_coleta_agencia_max: Número máximo de dias de coleta que agência pode realizar. custo_fixo: Custo fixo associado à agência. custo_litro_combustivel Custo combustível por litro (em R$). Padrão: 6. custo_hora_viagem Custo de cada hora de viagem (em R$). Padrão: 10. kml Consumo médio de combustível veículo (em km/l). Padrão: 10. valor_diaria Valor da diária para deslocamentos (em R$). Padrão: 335. diarias_entrevistador_max Máximo de diárias que um entrevistador pode receber período de referência. Padrão: Inf. remuneracao_entrevistador Remuneração por entrevistador para todo o período de referência. Padrão: 0. n_entrevistadores_min Número mínimo de entrevistadores por agência. Padrão: 1. dias_coleta_entrevistador_max Número de dias de coleta por entrevistador. dias_treinamento Número de dias/diárias para treinamento. Padrão: 0 (nenhum treinamento). agencias_treinadas (Opcional) Um vetor de caracteres com os códigos das agências que já foram treinadas e não terão custo de treinamento. Padrão: NULL. agencias_treinamento Código da(s) agência(s) onde o treinamento será realizado. distancias_ucs Um tibble ou data.frame com distâncias entre UCs e agências, incluindo: uc: Código da UC. agencia_codigo: Código da agência. distancia_km: Distância em quilômetros entre UC e agência. duracao_horas: Duração da viagem em horas entre UC e agência. diaria_municipio: Indica se é necessária uma diária para deslocamento entre UC e agência, considerando o município da UC. diaria_pernoite: Indica se é necessária uma diária com pernoite para deslocamento entre UC e agência. distancias_agencias Um tibble ou data.frame com distâncias entre agências, incluindo: agencia_codigo_orig: Código da agência de origem. agencia_codigo_dest: Código da agência de destino. distancia_km: Distância em quilômetros entre agência de origem e de destino. duracao_horas: Duração da viagem em horas entre agência de origem e de destino. adicional_troca_jurisdicao Custo adicional quando há troca de agência de coleta. Padrão: 0. resultado_completo (Opcional) Um valor lógico indicando se deve ser retornado um resultado mais completo, incluindo informações sobre todas combinações de UCs e agências. Padrão: FALSE. solver Qual ferramenta para solução modelo de otimização utilizar. Padrão: \"cbc\". Outras opções: \"glpk\", \"symphony\" (instalação manual). ... Opções adicionais para o solver.","code":""},{"path":"https://leoniedu.github.io/orce/reference/alocar_ucs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Alocação Otimizada de Unidades de Coleta (UCs) a Agências — alocar_ucs","text":"Uma lista contendo: resultado_ucs_jurisdicao: Um tibble com UCs e suas alocações originais (jurisdição), incluindo custos de deslocamento. resultado_agencias_jurisdicao: Um tibble com agências e suas alocações originais (jurisdição), incluindo custos fixos, custos de deslocamento e número de UCs alocadas. resultado_ucs_otimo: Um tibble com UCs e suas alocações otimizadas, incluindo custos de deslocamento. resultado_agencias_otimo: Um tibble com agências e suas alocações otimizadas, incluindo custos fixos, custos de deslocamento, número de UCs alocadas e número de entrevistadores. ucs_agencias_todas (opcional): Um tibble com todas combinações de UCs e agências, incluindo distâncias, custos e informações sobre diárias (retornado apenas se resultado_completo TRUE). otimizacao (opcional): O resultado completo da otimização (retornado apenas se resultado_completo TRUE).","code":""},{"path":"https://leoniedu.github.io/orce/reference/calcula_distancias.html","id":null,"dir":"Reference","previous_headings":"","what":"Calcula Distâncias Entre Origens e Destinos — calcula_distancias","title":"Calcula Distâncias Entre Origens e Destinos — calcula_distancias","text":"Esta função calcula distância e duração entre conjuntos de pontos de origem e destino usando o serviço OSRM.","code":""},{"path":"https://leoniedu.github.io/orce/reference/calcula_distancias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calcula Distâncias Entre Origens e Destinos — calcula_distancias","text":"","code":"calcula_distancias(destinos, origens, nmax = 2000)"},{"path":"https://leoniedu.github.io/orce/reference/calcula_distancias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calcula Distâncias Entre Origens e Destinos — calcula_distancias","text":"destinos Um objeto sf representando os pontos de destino. origens Um objeto sf representando os pontos de origem.","code":""},{"path":"https://leoniedu.github.io/orce/reference/calcula_distancias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calcula Distâncias Entre Origens e Destinos — calcula_distancias","text":"Um data frame com distâncias (em quilômetros) e durações (em horas) entre cada par de origem e destino.","code":""},{"path":"https://leoniedu.github.io/orce/reference/map_uc_agencias.html","id":null,"dir":"Reference","previous_headings":"","what":"Mapeia Unidades de Coleta (UCs) e Agências — map_uc_agencias","title":"Mapeia Unidades de Coleta (UCs) e Agências — map_uc_agencias","text":"Esta função cria um mapa exibindo localização das unidades de coleta (UCs) e agências. Ela utiliza o pacote 'ggmap' para obter um mapa de uma fonte especificada (por exemplo, Google Maps) e sobrepõe UCs e agências nele.","code":""},{"path":"https://leoniedu.github.io/orce/reference/map_uc_agencias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mapeia Unidades de Coleta (UCs) e Agências — map_uc_agencias","text":"","code":"map_uc_agencias(   data,   f = 0.05,   source = \"google\",   maptype = \"roadmap\",   zoom = \"auto\" )"},{"path":"https://leoniedu.github.io/orce/reference/map_uc_agencias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mapeia Unidades de Coleta (UCs) e Agências — map_uc_agencias","text":"data Um data frame contendo coordenadas das UCs e agências. Deve possuir colunas chamadas 'uc_lat', 'uc_lon', 'agencia_lat' e 'agencia_lon'. f Um valor numérico especificando fração pela qual expandir caixa delimitadora em torno das UCs e agências. O padrão é 0.05. source Uma string de caracteres especificando fonte mapa. O padrão é \"google\". maptype Uma string de caracteres especificando o tipo de mapa. O padrão é \"roadmap\". zoom Um número inteiro ou string \"auto\" especificando o nível de zoom. Se \"auto\", o nível de zoom é calculado automaticamente para ajustar todas UCs e agências.","code":""},{"path":"https://leoniedu.github.io/orce/reference/map_uc_agencias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mapeia Unidades de Coleta (UCs) e Agências — map_uc_agencias","text":"Um objeto ggplot representando o mapa com UCs e agências sobrepostas.","code":""}]
