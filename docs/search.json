[{"path":"https://leoniedu.github.io/orce/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 orce authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"introdução","dir":"Articles","previous_headings":"","what":"Introdução","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"otimização dos custos de coleta de dados é um desafio comum em instituições de pesquisa que lidam com grandes volumes de informações distribuídas geograficamente. caso IBGE, necessidade de otimizar alocação de setores censitários, escolas, ou empresas, às agências de coleta IBGE, se torna essencial, dada complexidade logística e os elevados custos envolvidos processo. pesquisas MUNIC (Pesquisa de Informações Básicas Municipais) e POF (Pesquisa de Orçamentos Familiares) são dois exemplos que ilustram importância dessa otimização. MUNIC, que coleta dados sobre gestão e estrutura dos municípios brasileiros, e POF, que investiga os hábitos de consumo das famílias brasileiras, envolvem coleta de dados em milhares de domicílios e municípios, gerando altos custos logísticos. O pacote orce é uma ferramenta projetada para otimizar alocação de Unidades de Coleta (UCs), como setores censitários, prefeituras de municípios ou estabelecimentos de ensino, às agências IBGE. eficiência dessa alocação é fundamental para garantir coleta de dados de forma econômica e eficaz em pesquisas e censos de grande escala, como o Censo Demográfico. Coletar dados em milhares de domicílios espalhados por um vasto território é um grande desafio. O orce entra em ação para ajudar definir melhor estratégia, minimizando o tempo de deslocamento e os custos envolvidos.","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"principais-características","dir":"Articles","previous_headings":"Introdução","what":"Principais Características","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Roteamento e Geocodificação: Para o caso em que unidades de coleta são setores censitários, função ponto_setor_densidade auxilia na identificação de locais representativos dentro dos setores censitários, priorizando áreas de alta densidade populacional para facilitar o acesso e garantir que o algorítimo de roteamento tenha destinos/origens válidos. Otimização Avançada da Alocação: O orce implementa um algoritmo inteligente que encontra melhor forma de distribuir UCs entre agências IBGE, levando em conta diversos fatores, como distância entre os locais, o tempo de viagem, os custos fixos de cada agência e necessidade de pagar diárias aos pesquisadores. função alocar_ucs permite que você personalize restrições, como capacidade de cada agência e preferências de localização, para que alocação se adapte às necessidades específicas seu projeto. função alocar_municipios, por sua vez, otimiza alocação mantendo unidades de coleta de um mesmo município com uma só agência. Cálculo de Custos Detalhados: O pacote considera fronteiras administrativas para determinar quando é necessário pagar diárias aos pesquisadores, garantindo que os custos totais sejam calculados com precisão. Outros custos importantes, como combustível e tempo de viagem, também são levados em conta para fornecer uma estimativa completa dos gastos da coleta de dados. Flexibilidade e Adaptabilidade: O orce permite que você personalize vários parâmetros, como o custo combustível, o custo por hora de viagem, o consumo de combustível por quilômetro e restrições específicas de cada agência. Essa flexibilidade garante que o pacote possa ser adaptado diferentes tipos de pesquisas e necessidades de coleta de dados, tornando-o uma ferramenta versátil para o IBGE.","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"impacto-e-aplicações","dir":"Articles","previous_headings":"Introdução","what":"Impacto e Aplicações","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"O pacote orce tem o potencial de gerar um impacto significativo na eficiência e na economicidade das operações de pesquisa e censo IBGE. Ao otimizar alocação de UCs, o pacote pode: Reduzir custos de viagem e tempo de deslocamento: Ao minimizar distâncias percorridas e o tempo gasto em viagens, o pacote contribui para redução dos custos operacionais e aumenta produtividade das equipes de coleta de dados. Otimizar utilização dos recursos das agências: alocação eficiente das UCs às agências garante que os recursos sejam utilizados de forma equilibrada. opção de impor límites máximos e mínimos de unidades de coleta por agência ajuda evitar sobrecarga em algumas agências e ociosidade em outras. Facilitar o planejamento e gestão da coleta de dados: capacidade de personalizar parâmetros e restrições permite que o pacote se adapte às necessidades específicas de cada projeto, facilitando o planejamento e gestão das operações de coleta de dados.","code":""},{"path":[]},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"caso-1--calculando-os-custos-da-coleta-da-munic","dir":"Articles","previous_headings":"Estudos de caso","what":"Caso 1. Calculando os custos da coleta da MUNIC","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Pesquisa de Informações Básicas Municipais (MUNIC) realizada pelo Instituto Brasileiro de Geografia e Estatística (IBGE) é uma pesquisa fundamental para coletar informações essenciais sobre os municípios em todo o Brasil. alocação eficiente dos municípios às agências IBGE responsáveis pela coleta de dados é um aspecto importante para o sucesso da pesquisa MUNIC, principalmente nas Unidades da Federação com maior número de agências e municípios. O processo envolve atribuir cada município à agência mais adequada, considerando fatores como proximidade geográfica, capacidade da agência e custos de viagem. complexidade dessa tarefa aumenta com o número de municípios e agências envolvidas, tornando alocação manual desafiadora e potencialmente levando atribuições abaixo ideal. Para enfrentar esse desafio, o pacote orce utiliza algoritmos avançados de otimização e incorpora vários fatores de custo para identificar estratégia de alocação mais eficiente, minimizando despesas de viagem, carga de trabalho da equipe e custos gerais da pesquisa. Vamos começar Superintendência Estadual Espírito Santo, que tem 78 municípios, e 10 agências IBGE.  Vamos supor que seja necessário visitar todos os 78 municípios. Como podemos estimar o custo da coleta? Partiremos de algumas premissas. Municípios na mesma microrregião ou região metropolitana não pagam diária, não ser que seja exigida pernoite. Quando o tempo de viagem é maior que 1,5 horas, paga-se diária, mesmo se na jurisdição da agência. coleta presencial dura 2 dias. Quando há pernoite, são pagas 1,5 diárias, e coleta é feita em 1 viagem(ns). Quando não há pernoite, são feitas 2 viagem(ns) (ida e volta). Há pagamento de meia-diária nos casos especificados item 1. viagens, feitas por veículos IBGE, tem origem nas agências e destino nos municípios de coleta. Os veículos fazem 10 quilômetros por litro, e o custo combustível é de 6 por litro. Importante: o consumo de combustível pode ser reduzido significativamente fazendo “roteiros”, em que uma viagem percorre mais de um município. Vamos ignorar, por enquanto, essa possibilidade. Diárias são calculadas para apenas um funcionário e tem o valor de 335. Os dados com unidades de coleta tem seguinte estrutura: Usamos como código da unidade de coleta (uc) o código IBGE município. Os dados devem ser únicos por uc. Dias de coleta (dias_coleta) e número de viagens (viagens) poderiam variar por município. Precisamos também da distância de cada agência para cada município, e se viagem paga diária quando não há pernoite. momento, estamos só analisando os municípios com respectivas agências de jurisdição, essa diária não é devida. Mas ao analisar alocações alternativas, é importante saber quando é que diárias são devidas. Essa informação está na tabela agencias_municipios_diaria, disponível pacote para todas unidades da federação. Precisamos também das distâncias, em quilômetros, entre cada agência e cada sede municipal (disponível em distancias_agencias_municipios_osrm), que combinamos com informações sobre diárias (agencias_municipios_diaria). Observação: coluna diaria_pernoite é calculada com base na duração da viagem (ida). partir de 1,5, são pagas diárias, mesmo se na jurisdição da agência. Estamos, agora, prontos para calcular os custos de coleta.","code":"map_uc_agencias(mnow%>%rename(uc_lat=municipio_sede_lat, uc_lon=municipio_sede_lon)) +   geom_point(aes(y=municipio_sede_lat, x=municipio_sede_lon, color=agencia_nome_bdo), data=mnow, alpha=3/4)+   geom_point(aes(y=agencia_lat, x=agencia_lon, color=agencia_nome_bdo), data=mnow, shape=2, size=3) +    labs(x=\"\", y=\"\", color=\"\") ucs_now <- municipios_22%>%   sf::st_drop_geometry()%>%   filter(substr(municipio_codigo,1,2)==ufnow$uf_codigo)%>%   left_join(agencias_bdo_mun%>%select(agencia_codigo, municipio_codigo), by=\"municipio_codigo\")%>%   mutate(uc=municipio_codigo)%>%   ## com agências intramunicipais tem mais de uma agência associada a município   ## vamos deixar só a primeira (em ordem numérica)   group_by(municipio_codigo)%>%   arrange(agencia_codigo)%>%   slice(1)%>%   mutate(viagens=params$viagens_munic, dias_coleta=params$dias_coleta_munic) gt1(ucs_now%>%       distinct(agencia_codigo, dias_coleta, viagens, .keep_all = TRUE)%>%       arrange(agencia_codigo, uc)%>%       head(10)%>%       ungroup%>%       select(uc=municipio_codigo, agencia_codigo, dias_coleta, viagens)) agencias_municipios_diaria%>%   semi_join(ucs_now, by=\"municipio_codigo\")%>%   distinct(agencia_codigo, diaria_municipio, .keep_all = TRUE)%>%   arrange(agencia_codigo)%>%   head(10)%>%gt1() distancias_ucs <- distancias_agencias_municipios_osrm%>%                     left_join(agencias_municipios_diaria_now,                               by = join_by(agencia_codigo, municipio_codigo))%>%                     mutate(uc=municipio_codigo)%>%   semi_join(ucs_now, by=\"uc\")%>%   mutate(diaria_pernoite=duracao_horas>params$horas_viagem_pernoite)  gt1(distancias_ucs%>%       distinct(agencia_codigo, diaria_municipio, diaria_pernoite, .keep_all = TRUE)%>%          select(agencia_codigo, uc, distancia_km,                                duracao_horas, diaria_municipio, diaria_pernoite)%>%       arrange(agencia_codigo, uc)%>%   head()) params_munic <- params[names(params)%in%params_alocar_ucs] params_munic$remuneracao_entrevistador <- 0  params_munic$agencias <- agencias_now%>%mutate(dias_coleta_agencia_max=params$dias_coleta_agencia_max_munic) params_munic$distancias_ucs <- distancias_ucs params_munic$ucs <- ucs_now params_munic$resultado_completo <- TRUE params_munic$dias_coleta_entrevistador_max <- params$dias_coleta_entrevistador_max_munic  print(lapply(params_munic,head,2)) #> $custo_hora_viagem #> [1] 10 #>  #> $custo_litro_combustivel #> [1] 6 #>  #> $kml #> [1] 10 #>  #> $valor_diaria #> [1] 335 #>  #> $adicional_troca_jurisdicao #> [1] 100 #>  #> $remuneracao_entrevistador #> [1] 0 #>  #> $solver #> [1] \"cbc\" #>  #> $max_time #> [1] 9000 #>  #> $rel_tol #> [1] 0,02 #>  #> $agencias #> Simple feature collection with 2 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: -41,5317 ymin: -20,8496 xmax: -41,1114 ymax: -20,7613 #> Geodetic CRS:  SIRGAS 2000 #> # A tibble: 2 × 10 #>   uf_codigo agencia_codigo agencia_nome            uorg  agencia_lat agencia_lon #>   <chr>     <chr>          <chr>                   <chr>       <dbl>       <dbl> #> 1 32        320020100      Alegre                  593         -20.8       -41.5 #> 2 32        320120900      Cachoeiro de Itapemirim 594         -20.8       -41.1 #> # ℹ 4 more variables: geometry <POINT [°]>, custo_fixo <dbl>, #> #   max_uc_agencia <dbl>, dias_coleta_agencia_max <chr> #>  #> $distancias_ucs #>   agencia_codigo municipio_codigo distancia_km duracao_horas diaria_municipio #> 1      320020100          3200102       132,51          2,20             TRUE #> 2      320120900          3200102       119,44          2,03            FALSE #>        uc diaria_pernoite #> 1 3200102            TRUE #> 2 3200102            TRUE #>  #> $ucs #> # A tibble: 2 × 14 #> # Groups:   municipio_codigo [2] #>   municipio_codigo municipio_sede_lon municipio_sede_lat municipio_nome #>   <chr>                         <dbl>              <dbl> <chr>          #> 1 3200102                       -41.1              -20.1 Afonso Cláudio #> 2 3200136                       -40.7              -19.0 Águia Branca   #> # ℹ 10 more variables: uf_codigo <chr>, uf_sigla <chr>, uf_nome <chr>, #> #   regiao_codigo <chr>, regiao_nome <chr>, municipio_populacao <int>, #> #   agencia_codigo <chr>, uc <chr>, viagens <int>, dias_coleta <int> #>  #> $resultado_completo #> [1] TRUE #>  #> $dias_coleta_entrevistador_max #> [1] 40 print(paste(\"parâmetros sem valor fixado: \", paste(setdiff(x=params_alocar_ucs, names(params_munic)), collapse=\", \"))) #> [1] \"parâmetros sem valor fixado:  diarias_entrevistador_max, n_entrevistadores_min, dias_treinamento, agencias_treinadas, agencias_treinamento, distancias_agencias\" res <- do.call(what = alocar_ucs,                args=params_munic)"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"custos-por-agência","dir":"Articles","previous_headings":"Estudos de caso > Caso 1. Calculando os custos da coleta da MUNIC","what":"Custos por agência","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"","code":"j <- res$resultado_ucs_jurisdicao%>%   left_join(agencias_now%>%sf::st_drop_geometry(), by=\"agencia_codigo\")%>%   left_join(assistencias, by=\"agencia_codigo\")%>%   group_by(assistencia_nome, agencia_nome)%>%   mutate(municipios=1)%>%   summarise(across(c(municipios, total_diarias, custo_diarias, distancia_total_km, custo_combustivel), sum)) #> `summarise()` has grouped output by 'assistencia_nome'. You can override using #> the `.groups` argument. gt(j%>%ungroup, groupname_col = 'assistencia_nome', rowname_col='agencia_nome')%>%   gt::summary_rows(fns = list(fn='sum', label=\"Total da Assistência\"), fmt=~fmt_nums(.))%>%   fmt_nums()%>%   gt::cols_label_with(fn=\"nomear_colunas\")%>%   gt::grand_summary_rows(fns = list(fn='sum', label=\"Total da Superintendência\")                          , fmt = ~fmt_nums(.))%>%   print_gt() resultado_ucs <- bind_rows(   res$resultado_ucs_otimo%>%mutate(plano= \"otimo\"),   res$resultado_ucs_jurisdicao%>%mutate(plano= \"jurisdicao\"))%>%   group_by(uc)%>%   mutate(mudanca=length(unique(agencia_codigo))>1) toexport <- res$resultado_ucs_jurisdicao%>%   rename(municipio_codigo=uc)%>%   left_join(agencias_now%>%sf::st_drop_geometry(), by = join_by(agencia_codigo))%>%   left_join(municipios_22%>%select(municipio_codigo, municipio_nome), by = join_by(municipio_codigo))%>%   left_join(assistencias, by = join_by(agencia_codigo))%>%   transmute(     assistencia_nome,     agencia_codigo, agencia_nome,     municipio_nome, municipio_codigo,             distancia_km, duracao_horas, diaria, meia_diaria, trechos, total_diarias, custo_diarias, distancia_total_km, custo_combustivel, custo_horas_viagem, custo_deslocamento)    # export_dir <- file.path(here::here(\"vignettes\", \"articles\", \"munic\")) # dir.create(export_dir, recursive = TRUE, showWarnings = FALSE) # export_path <- file.path(export_dir,paste0(\"munic_\", ufnow$uf_codigo, \"_\", format(Sys.time(), \"%Y%m%d_%H\"), \".xlsx\")) # toexport_l <- lapply(toexport%>%split(.$assistencia_nome), function(x) janitor::remove_constant(x)) #sigba::excel(toexport_l, filename = export_path)"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"custos-por-município","dir":"Articles","previous_headings":"Estudos de caso > Caso 1. Calculando os custos da coleta da MUNIC","what":"Custos por município","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"","code":"mnow%>%   left_join(res$resultado_ucs_jurisdicao, by=c(\"municipio_codigo\"=\"uc\", \"agencia_codigo\"))%>%   transmute(municipio_nome, agencia_nome=capitalizar(agencia_nome), custo_diarias, custo_combustivel)%>%   sf::st_drop_geometry()%>%   arrange(desc(custo_diarias+custo_combustivel))%>%   head(10)%>%   gt1()"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"lidando-com-contigências-da-coleta","dir":"Articles","previous_headings":"Estudos de caso > Caso 1. Calculando os custos da coleta da MUNIC","what":"Lidando com contigências da coleta","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Suponha agora que é necessário fazer uma visita ao município de Barra de São Francisco, mas agência de jurisdição não está disponível por qualquer motivo (férias, licença de saúde, veículo IBGE quebrado, etc.) Quais são agências alternativas para realizar essa coleta? função alocar_ucs retorna, opcionalmente, lista completa de combinações entre agências XX municípios, que permite facilmente responder essa pergunta. Nota-se que outras agências podem realizar coleta municípios, e qual custo.","code":"munnow <- municipios_22%>%filter(municipio_codigo=='3200904') res$ucs_agencias_todas%>%   semi_join(munnow, by=c(\"uc\"=\"municipio_codigo\"))%>%   left_join(agencias_now, by=\"agencia_codigo\")%>%   mutate(jurisdicao=agencia_codigo_jurisdicao==agencia_codigo)|>   transmute(agencia_nome=glue::glue(\"{agencia_nome} {if_else(jurisdicao, '(Jurisdição)', '')}\"), duracao_horas, distancia_km, custo_diarias, custo_combustivel)%>%   arrange(custo_diarias+custo_combustivel)%>%   head(4)%>%   gt::gt()|>   print_gt()"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"otimizando-a-alocação-de-municípios","dir":"Articles","previous_headings":"Estudos de caso > Caso 1. Calculando os custos da coleta da MUNIC","what":"Otimizando a alocação de municípios","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"pergunta que segue, naturalmente, é, há algum município que teria custos de coleta menores se coleta fosse realizada por agência diferente da de jurisdição? resposta é sim! Sabemos que os custos com combustível e diárias estão longe de ser os únicos fatores para selecionar agência de coleta. própria troca de agência de coleta tem um custo não desprezível. Os funcionários da agência de jurisdição provavelmente conhecem melhor o município de coleta, e até na gerência da coleta (que agência mesmo coleta o município X?) têm custos. Outras possibilidade é distância em quilômetros ser menor, mas o tempo de viagem (por conta de qualidade da estrada, por exemplo) ser maior. O tempo gasto viajando certamente tem um custo para além das diárias e combustível. Propomos avaliar o custo de deslocamento como soma custo de diárias, combustível, e custo adicional por hora de viagem correspondente R$10. Além disso, só são propostas trocas que economizariam mínimo R$100 custo de deslocamento para o município.","code":"res$ucs_agencias_todas%>%   group_by(municipio_codigo=uc)%>%   mutate(custo_diaria_combustivel=custo_diarias+custo_combustivel)%>%   arrange(custo_diaria_combustivel)%>%   slice(1)%>%   filter(agencia_codigo_jurisdicao!=agencia_codigo)|>   left_join(agencias_now, by=\"agencia_codigo\")%>%   left_join(mnow%>%sf::st_drop_geometry()%>%               select(municipio_codigo,municipio_nome))%>%   ungroup%>%   transmute(municipio_nome, agencia_nome, distancia_km, duracao_horas, custo_diarias, custo_combustivel)%>%   arrange(custo_diarias+custo_combustivel)%>%   gt::gt()|>   print_gt() #> Joining with `by = join_by(municipio_codigo)` mudancas <- resultado_ucs%>%   filter(mudanca)%>%   left_join(agencias_now%>%select(agencia_codigo,                                    agencia_nome,                                   agencia_lat,                                   agencia_lon), by=\"agencia_codigo\")%>%   left_join(municipios_22%>%               sf::st_drop_geometry()%>%               select(uc=municipio_codigo, municipio_nome, municipio_sede_lat, municipio_sede_lon), by=\"uc\")%>%   mutate(uc_lat=municipio_sede_lat, uc_lon=municipio_sede_lon)%>%   ungroup()  if (nrow(mudancas)>0) {   gt(     mudancas%>%       select(agencia_nome, municipio_nome, distancia_km, custo_deslocamento, plano)%>%       tidyr::pivot_wider(names_from = c(\"plano\"), id_cols = c(\"municipio_nome\"), values_from=c(\"agencia_nome\", \"distancia_km\", \"custo_deslocamento\"))#%>%arrange(agencia_nome_otimo)   )%>%     gt::cols_label_with(fn=\"nomear_colunas\")|>     print_gt() } if (nrow(mudancas)>0) {  mudancas_l <- mudancas%>%group_split(municipio_nome)   for (i in seq_along(mudancas_l)) {     dnow <- mudancas_l[[i]]%>%       arrange(plano)%>%       mutate(title=glue::glue(\"{municipio_nome}:\\n.  de {agencia_nome[1]}\\n   para {agencia_nome[2]}\"),     subtitle=glue::glue(\"{agencia_nome}: {round(distancia_km)} km (R$ {round(custo_deslocamento)})\"))     p <- map_uc_agencias(dnow) +       geom_label(aes(x=municipio_sede_lon, y=municipio_sede_lat, label=municipio_nome), data=dnow[1,], size=3) +       geom_label(aes(x=agencia_lon, y=agencia_lat, label=agencia_nome), data=dnow, size=3) +     theme_minimal() +       labs(title = dnow$title[1], caption = paste(dnow$subtitle, collapse='\\n'), x=\"\",y=\"\")+       guides(color=\"none\")     print(p)   } }"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"resumo-da-otimização","dir":"Articles","previous_headings":"Estudos de caso > Caso 1. Calculando os custos da coleta da MUNIC","what":"Resumo da otimização","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Utilizando o plano otimizado, com 4 alterações de agência de coleta, é possível economizar 8% valor das diárias, gastando o mesmo valor em combustível.","code":"resultado_ucs%>%   transmute(agencia_codigo, custo_diarias, custo_combustivel, custo_horas_viagem, total=custo_deslocamento, plano)%>%   group_by(plano)%>%   summarise(across(where(is.numeric), sum), n_agencias=n_distinct(agencia_codigo))%>%   tidyr::pivot_longer(cols=-plano)%>%   tidyr::pivot_wider(names_from=plano)%>%   mutate(reducao=jurisdicao-otimo,          reducao_pct=1-otimo/jurisdicao) -> resumo_planos resumo_planos%>%   gt::gt()%>%   print_gt() economia_diarias <- resumo_planos%>%filter(name==\"custo_diarias\")%>%pull(reducao_pct) economia_combustivel <- resumo_planos%>%filter(name==\"custo_combustivel\")%>%pull(reducao_pct)%>%round(2) if (economia_combustivel > 0) {   economia_combustivel_str <-   glue::glue(\"{round(economia_combustivel*100,1)}% a **menos**\") } else if (economia_combustivel<0) {   economia_combustivel_str <-  glue::glue(\"apenas {-round(economia_combustivel*100,1)}% a mais\") } else {   economia_combustivel_str <- \"o mesmo valor\" } ufs_sem_missing_dist <- distancias_agencias_municipios_osrm%>%   group_by(uf_codigo=substr(agencia_codigo,1,2))%>%   filter(all(!is.na(distancia_km)))%>%   distinct(uf_codigo)%>%   pull(uf_codigo)%>%sort() ufs_sem_missing_dist <- ufs_sem_missing_dist[ufs_sem_missing_dist!=53]"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"resultados-para-outras-superintendências-estaduais","dir":"Articles","previous_headings":"Estudos de caso > Caso 1. Calculando os custos da coleta da MUNIC","what":"Resultados para outras Superintendências Estaduais1","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"","code":"filter_uf <- function(x) {   x%>%     filter(substr(agencia_codigo,1,2)==ufnow$uf_codigo,             !agencia_codigo%in%c(\"130420300\",\"130140700\"),            !municipio_codigo%in%c(\"1300300\", \"1301001\", \"1301407\", \"1301951\", \"1303106\", \"1304203\")) }   res_ufs <- vector(mode = \"list\", length = length(ufs_sem_missing_dist)) names(res_ufs) <- as.character(ufs_sem_missing_dist) for (uf_codigo_now in ufs_sem_missing_dist) {   params_uf <- params_munic   ufnow <- ufs%>%filter(uf_codigo==uf_codigo_now)   distancias_ucs <- distancias_agencias_municipios_osrm%>%     left_join(agencias_municipios_diaria_now,               by = join_by(agencia_codigo, municipio_codigo))%>%     mutate(uc=municipio_codigo)%>%     filter_uf()   stopifnot(nrow(distancias_ucs%>%filter(is.na(distancia_km)))==0)      ucs_now <- distancias_ucs%>%     distinct(municipio_codigo)%>%     left_join(agencias_bdo_mun%>%select(agencia_codigo, municipio_codigo), by=\"municipio_codigo\")%>%     mutate(uc=municipio_codigo)%>%     ## com agências intramunicipais tem mais de uma agência associada a município     ## vamos deixar só a primeira (em ordem numérica)     group_by(municipio_codigo)%>%     arrange(agencia_codigo)%>%     slice(1)%>%     mutate(viagens=params$viagens_munic, dias_coleta=params$dias_coleta_munic)%>%     filter_uf()      params_munic$agencias <- NULL   params_munic$distancias_ucs <- distancias_ucs%>%mutate(diaria_pernoite=duracao_horas>params$horas_viagem_pernoite)   params_munic$ucs <- ucs_now   params_munic$resultado_completo <- FALSE   res <- do.call(what = alocar_ucs,                   args=params_munic)      resultado_ucs <- bind_rows(     res$resultado_ucs_otimo%>%mutate(plano= \"otimo\"),     res$resultado_ucs_jurisdicao%>%mutate(plano= \"jurisdicao\"))%>%     group_by(uc)%>%     mutate(mudanca=length(unique(agencia_codigo))>1)          resultado_ucs%>%     transmute(agencia_codigo, custo_diarias, custo_combustivel, custo_horas_viagem, total=custo_deslocamento, plano)%>%     group_by(plano)%>%     summarise(across(where(is.numeric), sum), n_agencias=n_distinct(agencia_codigo))%>%     tidyr::pivot_longer(cols=-plano)%>%     tidyr::pivot_wider(names_from=plano)%>%     mutate(reducao=jurisdicao-otimo,            reducao_pct=1-otimo/jurisdicao,uf_codigo=uf_codigo_now) -> resumo_planos   res_ufs[[as.character(uf_codigo_now)]] <- resumo_planos }  res_ufs_df <- bind_rows(res_ufs)%>%filter(name==\"total\")%>%left_join(ufs, by=\"uf_codigo\")  res_ufs_df%>%   ungroup%>%   select(regiao_nome, uf_nome, jurisdicao, otimo, reducao, reducao_pct)%>%   arrange(regiao_nome, desc(reducao))%>%   group_by(regiao_nome)%>%   gt()%>%   gt::summary_rows(fns=list(fn=\"sum\", label=\"Total da Região\"), columns = c(\"jurisdicao\", \"otimo\", \"reducao\"), fmt = ~fmt_nums(.x, decimal_num = 0))%>%   gt::grand_summary_rows(fns=list(fn='sum', label=\"Total Brasil\"), columns = c(\"jurisdicao\", \"otimo\", \"reducao\"),fmt = ~fmt_nums(.x, decimal_num = 0))%>%   gt::cols_label(uf_nome=\"\", jurisdicao=\"Jurisdição (R$)\", otimo=\"Ótimo (R$)\", reducao=\"Redução (R$)\", reducao_pct=\"Redução (%)\")%>%   print_gt(decimal_num=0, processar_nomes_colunas = FALSE) # ggplot(data = res_ufs_df%>%mutate(uf_nome=forcats::fct_reorder(uf_nome, reducao)), aes(x=reducao, y=uf_nome)) + #   geom_point() + #   scale_x_continuous(labels=scales::label_currency(prefix = \"R$ \", decimal.mark = \",\", big.mark = \".\")) + #   labs(subtitle=\"Redução total nos custos de descolamento do plano ótimo\\nem comparação com a manutenção das agência de jurisdição\", x=\"\", y=\"\")"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"caso-2--considerando-os-custos-com-entrevistadores-a-coleta-da-pof-2024-25-na-superintendência-estadua-da-bahia-sesba","dir":"Articles","previous_headings":"Estudos de caso","what":"Caso 2. Considerando os custos com entrevistadores: a coleta da POF 2024-25 na Superintendência Estadua da Bahia (SES/BA)","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Vamos agora considerar coleta da Pesquisa de Orçamentos Familiares (POF) na Bahia, planejada para ocorrer entre 2024 e 2025.","code":"uf_codigo_now <- 29 ufnow <- ufs%>%filter(uf_codigo==uf_codigo_now) ## amostra_pof load(file.path(pof2024ba:::package$cache_dir, \"amostra_preliminar.rda\"))  amostra_uf <- amostra_preliminar%>%   filter(substr(upa,1,2)==ufnow$uf_codigo)%>%   filter(!grepl(\"^2927408\" ,agencia_codigo))%>%   distinct(upa, .keep_all = TRUE)%>%   rename(uc=upa)%>%   mutate(     dias_coleta = params$dias_coleta_pof,     viagens = params$viagens_pof)#%>%ungroup()%>%slice_sample(n=100)  ## distancias upas distancias_upas <- readRDS(\"/Users/eleon/gitlab/orce/data-raw/distancias_agencias_setores_osrm.rds\")%>%   rename(uc=setor)%>%   mutate(municipio_codigo=substr(uc,1,7))%>%   left_join(agencias_municipios_diaria, by=c(\"agencia_codigo\", \"municipio_codigo\"))%>%   semi_join(amostra_uf, by=\"uc\")%>%   mutate(diaria_pernoite=duracao_horas>params$horas_viagem_pernoite)"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"parâmetros-iniciais","dir":"Articles","previous_headings":"Estudos de caso > Caso 2. Considerando os custos com entrevistadores: a coleta da POF 2024-25 na Superintendência Estadua da Bahia (SES/BA)","what":"Parâmetros iniciais","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Por conta de restrições cronograma de coleta, que deve ser realizada em períodos específicos, POF tem um mínimo de dois entrevistadores por agência. Em um ano de coleta, cada entrevistador poderá trabalhar 200 dias. Quando coleta é feita com diária (pernoite), são necessárias 2 viagens. O total de dias de coleta por Unidade Primária de Amostragem (composta por um ou mais setores censitários) é 10. O deslocamento envolve, portanto, 10 idas e voltas para setores sem pernoite, ou 2 idas e voltas para os casos sem pernoite. Nesse caso básico, sem incluindo somente os custos de deslocamento, o resultado é o seguinte. Redução de custos promovido pela otimização da rede de coleta tabela demonstra o impacto da otimização da rede de coleta em diferentes cenários, considerando custos fixos, diárias, combustível e número de agências envolvidas2. Principais Observações: Em todos os cenários, otimização resultou em redução significativa custo total. Realocação de UPAs entre agências: redistribuição ótima de UPAs entre agências, sem alteração número de agências na coleta, tem o não desprezível impacto de R$ 19 mil. Custo de treinamento: Se incluímos os custos de treinamento (2 funcionários por agência) o número de agência ótimo diminui bastante (cerca de 30%), e o valor economizado salta para cerca de R$ 55 mil. O custo de deslocamento (total de combustível e diárias) aumenta após otimização. Isso é explicado pela necessidade de percorrer distâncias maiores para cobrir UCs com uma rede menor de agências. entanto, esse aumento é mais que compensado pela redução dos custos com treinamento, resultando em uma economia geral. Custos com remuneração dos entrevistadores: Quando incluímos despesa com e remuneração dos entrevistadores, além custo de treinamento dos mesmos, economia gerada passa de R$ 1 milhão. É definitivamente aqui que está o mais efetivo instrumento para reduzir os custos de coleta.","code":"## sem custo fixo nem custo de treinamento params_pof_0  <- list(ucs=amostra_uf,            custo_litro_combustivel = params$custo_litro_combustivel,            custo_hora_viagem = params$custo_hora_viagem,            kml = params$kml,            valor_diaria = params$valor_diaria,            dias_treinamento = 0,            agencias_treinadas = NULL,            agencias_treinamento  = NULL,            distancias_ucs=distancias_upas,            adicional_troca_jurisdicao  = params$adicional_troca_jurisdicao,            remuneracao_entrevistador=0,            n_entrevistadores_min=2,             dias_coleta_entrevistador_max=params$dias_coleta_entrevistador_max_pof,            solver=params$solver,            max_time=params$max_time,            rel_tol=params$rel_tol            )  print(lapply(params_pof_0, head)) #> $ucs #> # A tibble: 6 × 11 #>   uc              setor    estrato_pof trimestre municipio_codigo municipio_nome #>   <chr>           <chr>          <dbl>     <dbl> <chr>            <chr>          #> 1 290570105000184 2905701…        2908         1 2905701          CAMACARI       #> 2 290650105000025 2906501…        2908         1 2906501          CANDEIAS       #> 3 290650105000106 2906501…        2908         1 2906501          CANDEIAS       #> 4 292100505000006 2921005…        2908         1 2921005          MATA DE SAO J… #> 5 293320815000003 2933208…        2909         1 2933208          VERA CRUZ      #> 6 290080125000015 2900801…        2910         1 2900801          ALCOBACA       #> # ℹ 5 more variables: agencia_codigo <chr>, agencia_nome <chr>, #> #   situacao_tipo <chr>, dias_coleta <int>, viagens <int> #>  #> $custo_litro_combustivel #> [1] 6 #>  #> $custo_hora_viagem #> [1] 10 #>  #> $kml #> [1] 10 #>  #> $valor_diaria #> [1] 335 #>  #> $dias_treinamento #> [1] 0 #>  #> $agencias_treinadas #> NULL #>  #> $agencias_treinamento #> NULL #>  #> $distancias_ucs #>                uc agencia_codigo distancia_km duracao_horas agencia_lat #> 1 290035505000027      290070200       263,82          4,01   -12,14108 #> 2 290035505000027      290320100      1007,91         13,63   -12,14613 #> 3 290035505000027      290390400       936,28         13,10   -13,25474 #> 4 290035505000027      290460500       682,01          9,84   -14,20330 #> 5 290035505000027      290490200       307,16          4,50   -12,60476 #> 6 290035505000027      290570100       348,16          4,82   -12,70437 #>   agencia_lon   ponto_origem setor_lat setor_lon municipio_codigo #> 1   -38,42650 pontos_setores -10,67762 -38,01224          2900355 #> 2   -44,99788 pontos_setores -10,67762 -38,01224          2900355 #> 3   -43,40660 pontos_setores -10,67762 -38,01224          2900355 #> 4   -41,67101 pontos_setores -10,67762 -38,01224          2900355 #> 5   -38,96288 pontos_setores -10,67762 -38,01224          2900355 #> 6   -38,32298 pontos_setores -10,67762 -38,01224          2900355 #>   diaria_municipio diaria_pernoite #> 1             TRUE            TRUE #> 2             TRUE            TRUE #> 3             TRUE            TRUE #> 4             TRUE            TRUE #> 5             TRUE            TRUE #> 6             TRUE            TRUE #>  #> $adicional_troca_jurisdicao #> [1] 100 #>  #> $remuneracao_entrevistador #> [1] 0 #>  #> $n_entrevistadores_min #> [1] 2 #>  #> $dias_coleta_entrevistador_max #> [1] 200 #>  #> $solver #> [1] \"cbc\" #>  #> $max_time #> [1] 9000 #>  #> $rel_tol #> [1] 0,02 print(paste(\"parâmetros sem valor fixado: \", paste(setdiff(x=params_alocar_ucs, names(params_pof_0)), collapse=\", \"))) #> [1] \"parâmetros sem valor fixado:  agencias, diarias_entrevistador_max, distancias_agencias, resultado_completo\" dagencias <- distancias_agencias_osrm params_pof_1 <- modifyList(params_pof_0,                             list(                              distancias_agencias=distancias_agencias_osrm,                              dias_treinamento = params$dias_treinamento_pof,# por funcionário                              agencias_treinamento  = c('292740800', '291080000'))) print(paste(\"parâmetros sem valor fixado: \", paste(setdiff(x=params_alocar_ucs, names(params_pof_1)), collapse=\", \"))) #> [1] \"parâmetros sem valor fixado:  agencias, diarias_entrevistador_max, resultado_completo\"   estrategias_pof <- bind_rows(   tibble(params_pof=list(params_pof_0),           descricao='Somente deslocamento'),   tibble(params_pof=list(params_pof_1), descricao=\"Custo de treinamento\"),   # tibble(params_pof=list(modifyList(params_pof_1,    #                               list(   #                                 ## diárias só com mais de duas horas de viagem   #                                 distancias_ucs=distancias_upas%>%   #                                   mutate(diaria_pernoite=duracao_horas>2)))),    #        descricao=\"Custo de treinamento + redução diárias por pernoite\"),   tibble(params_pof=list(modifyList(params_pof_1,                                  list(remuneracao_entrevistador=params$remuneracao_entrevistador*12))), descricao='Custo de treinamento + remuneração dos apms'),   # , tibble(params_pof=list(modifyList(params_pof_1,    #                               list(   #                                 adicional_troca_jurisdicao=300))),    #        descricao='custo de treinamento  + Adicional troca de jurisdição R$300')   )%>%   mutate(resultado=purrr::map(params_pof, ~do.call(alocar_ucs, .x), .progress = TRUE))  estrategias_pof_sum <-    estrategias_pof%>%   rowwise(descricao)%>%   reframe(     bind_rows(       resultado$resultado_agencias_otimo%>%mutate(modelo=\"Ótimo\"),       resultado$resultado_agencias_jurisdicao%>%mutate(modelo=\"Jurisdição\"))%>%       group_by(modelo)%>%       mutate(n_agencias=1)%>%       summarise(         across(matches(\"custo|n_agencias\"), ~sum(.x, na.rm=TRUE)),         ))%>%   mutate(custo_total=custo_deslocamento+custo_fixo+custo_total_entrevistadores)%>%   select(descricao, modelo, n_agencias, custo_total, everything()) report_plans(estrategias_pof$resultado[[1]])%>%   gt::cols_hide(-matches(c(\"agencia_nome\", \"n_uc\", \"total_diarias\", \"combustivel\", \"custo_total\", \"custo_troca\"))) #> Joining with `by = join_by(agencia_codigo)` vs <- c(\"n_agencias\", \"custo_total\", 'custo_total_entrevistadores', 'custo_diarias', 'custo_combustivel') pct <- function(x) (x[2]/x[1])-1 estrategias_pof_sum%>%   group_by(descricao)%>%   #arrange(modelo)%>%   select(-modelo)%>%   summarise(across(everything(), diff, .names = \"{.col}_dif\"),             across(-ends_with(\"_dif\"), pct, .names = \"{.col}_pct\")             )%>%   select(descricao, starts_with(vs))%>%   arrange(desc(n_agencias_dif))%>%   gt::gt() -> sumario_pof_0  sumario_pof <- sumario_pof_0 for (i in c(\"n_agencias\", \"custo_total\", 'custo_total_entrevistadores', 'custo_diarias', 'custo_combustivel')) {   sumario_pof <- sumario_pof%>%     fmt_percent(matches(\"_pct\"), decimals = 0)%>%     gt::cols_merge_n_pct(col_pct = paste0(i,\"_pct\"), col_n = paste0(i, \"_dif\")) } sumario_pof%>%   fmt_currency(matches(\"_dif\"), decimals = 0)%>%   fmt_number(matches(\"n_agencias_dif\"), decimals = 0)%>%   gt::cols_label(descricao='Modelo')%>%   gt::cols_label_with(fn = ~ gsub(\"_dif\", \"\", .x))%>%   gt::tab_caption(\"Redução de custos promovido pela otimização da rede de coleta\")%>%   print_gt()"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"caso-3--um-novo-modelo-de-coleta-nas-agências","dir":"Articles","previous_headings":"Estudos de caso","what":"Caso 3. Um novo modelo de coleta nas Agências","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"seção anterior demonstrou que, pelo menos caso da coleta da POF da Bahia, é possível atingir uma significativa redução de custos de coleta, quando contabilizamos remuneração dos entrevistadores. Investigamos nessa seção se, ao contabilizar outras pesquisas IBGE executadas pelas agências, em conjunto, redução de custos ainda é observada. lista de pesquisas incluídas é incompleta, mas já nos possibilita ter alguma ideia sobre, na perspectiva modelo de otimização orce, estrutura ideal da rede de coleta IBGE. Temos, até o momento: Pesquisas da Amostra Mestra (Domiciliares): Pesquisa Nacional por Amostra de Domicílios Contínua - PNADC Cadastro Nacional de Endereços para Fins Estatísticos - CNEFE Pesquisa de Orçamentos Familiares (POF) Pesquisas Municipais Duas visitas por ano para cada um dos municípios Estado. (Por exemplo, Munic e alguma outra.) Redução de custos promovido pela otimização da rede de coleta","code":"## amostra mestra/pnadc amostra_mestra <- readr::read_rds(here::here(\"data-raw/amostra_br_2024_01_2025_06.rds\"))%>%   filter(ano_mes>=as.Date(\"2024-07-01\"), ano_mes<=as.Date(\"2025-06-01\"))  amostra_pnadc <- amostra_mestra%>%   distinct(uc=upa, pesquisa=paste(\"pnadc\", substr(ano_mes,1,7)), agencia_codigo, dias_coleta=params$dias_coleta_pnadc, viagens=params$viagens_pnadc)  library(lubridate)## so months works #>  #> Attaching package: 'lubridate' #> The following objects are masked from 'package:base': #>  #>     date, intersect, setdiff, union amostra_cnefe <- amostra_mestra%>%   filter(entrevista_numero==1)%>%   mutate(ano_mes=ano_mes-months(3))%>%   distinct(uc=upa, pesquisa=paste(\"cnefe\", substr(ano_mes,1,7)), agencia_codigo, dias_coleta=params$dias_coleta_cnefe, viagens=params$viagens_cnefe)  ## amostra pof load(file.path(pof2024ba:::package$cache_dir, \"amostra_preliminar.rda\")) amostra_pof <- amostra_preliminar%>%   distinct(uc=upa, pesquisa=paste(\"pof\", if_else(trimestre==1, 2024, 2025), if_else(trimestre==1, 4, trimestre-1)), agencia_codigo=as.character(agencia_codigo), dias_coleta=params$dias_coleta_pof, viagens=params$viagens_pof)  ## municipais municipais <- municipios_22%>%   sf::st_drop_geometry()%>%   left_join(agencias_bdo_mun%>%select(agencia_codigo, municipio_codigo), by=\"municipio_codigo\")%>%   mutate(uc=municipio_codigo)%>%   ## com agências intramunicipais tem mais de uma agência associada a município   ## vamos deixar só a primeira (em ordem numérica)   group_by(municipio_codigo)%>%   arrange(agencia_codigo)%>%   slice(1)%>%   ungroup()%>%   distinct(uc, pesquisa=\"municipais\", agencia_codigo, viagens=params$viagens_municipios_carga, dias_coleta=params$dias_coleta_municipios_carga)   carga_br <- bind_rows(amostra_cnefe, amostra_pnadc, amostra_pof, municipais)%>%   group_by(uc, agencia_codigo, municipio_codigo=substr(uc,1,7))%>%   summarise(dias_coleta=sum(dias_coleta), viagens=sum(viagens)) #> `summarise()` has grouped output by 'uc', 'agencia_codigo'. You can override #> using the `.groups` argument.   uf_codigo_now <- 29 ufnow <- ufs%>%filter(uf_codigo==uf_codigo_now)  carga_uf <- carga_br%>%   filter(substr(uc,1,2)==ufnow$uf_codigo)%>%   ## Importante: Sem as agências de Salvador   filter(!grepl(\"2927408\", agencia_codigo))%>%   #ungroup#%>%filter(agencia_codigo%in%c(\"291360600\", \"291480200\", \"292870300\", \"293290300\", \"290490200\", \"292740800\", \"292740801\", \"291640100\"))   ungroup#%>%filter(agencia_codigo%in%unique(agencia_codigo)[1:20])  ## distancias uc distancias_ucs_all <- readRDS(\"/Users/eleon/gitlab/orce/data-raw/distancias_agencias_setores_osrm.rds\")%>%   rename(uc=setor)%>%   bind_rows(distancias_agencias_municipios_osrm%>%rename(uc=municipio_codigo))%>%   transmute(uc, agencia_codigo, distancia_km, duracao_horas, municipio_codigo=substr(uc,1,7))%>%   left_join(agencias_municipios_diaria, by=c(\"agencia_codigo\", \"municipio_codigo\"))%>%   semi_join(carga_uf, by=\"uc\")%>%   mutate(diaria_pernoite=duracao_horas>params$horas_viagem_pernoite)   agencias_uf <-  carga_uf%>%   group_by(agencia_codigo)%>%   summarise(n_ucs_jurisdicao=n(), dias_coleta_jurisdicao=sum(dias_coleta))%>%   mutate(uc_agencia_max=Inf,           dias_coleta_agencia_max=pmax(dias_coleta_jurisdicao, params$dias_coleta_agencia_max_carga), custo_fixo=0)   ## sem custo fixo nem custo de treinamento params_carga_0  <- list(ucs=carga_uf,                         agencias=agencias_uf,                         custo_litro_combustivel = params$custo_litro_combustivel,                         custo_hora_viagem = params$custo_hora_viagem,                         kml = params$kml,                         valor_diaria = params$valor_diaria,                         ## em um ano de coleta, um entrevistador consegue                         ## 48 upas pnadc / 24 upas POF / 18 Municipios                         dias_coleta_entrevistador_max=params$dias_coleta_entrevistador_max_carga,                         diarias_entrevistador_max=Inf,                         dias_treinamento = 0,                         agencias_treinadas = NULL,                         agencias_treinamento  = NULL,                         distancias_ucs=distancias_ucs_all,                         ## for symphony solver                         #gap_limit=5,                          adicional_troca_jurisdicao  = params$adicional_troca_jurisdicao,                         solver=params$solver,                         max_time=params$max_time,                         rel_tol=params$rel_tol,                         resultado_completo=FALSE                          ) library(tictoc) #tic() estrategias_carga <- bind_rows(   tibble(params_carga=list(params_carga_0),           descricao='sem custo fixo / sem custo de treinamento'),   tibble(params_carga=list(modifyList(params_carga_0,                                        list( remuneracao_entrevistador=12*2500)   )),    descricao='sem mínimo de entrevistador, remuneracao 2500, sem custo fixo'),   tibble(params_carga=list(modifyList(params_carga_0,                                        list(                                         agencias=agencias_uf,                                         remuneracao_entrevistador=12*params$remuneracao_entrevistador)   )),    descricao='sem mínimo de entrevistador, sem custo fixo'),      tibble(params_carga=list(modifyList(params_carga_0,                                        list(n_entrevistadores_min=2,                                         remuneracao_entrevistador=12*params$remuneracao_entrevistador,                                         max_time=params$max_time)   )),    descricao='mínimo de 2 entrevistadores, sem custo fixo'),         tibble(params_carga=list(modifyList(params_carga_0,                                        list(                                         agencias=agencias_uf%>%                                           mutate(                                             custo_fixo=10000*12),                                         n_entrevistadores_min=2,                                         remuneracao_entrevistador=12*params$remuneracao_entrevistador,                                         max_time=max(params$max_time, 60*60)                                         #max_time=                                       ))),           descricao='mínimo de 2 entrevistadores /2 Técnicos 10000 p/ mes (custo fixo)'),   tibble(params_carga=list(modifyList(params_carga_0,                                        list(                                         distancias_ucs=params_carga_0$distancias_ucs%>%                                           mutate(diaria_municipio=FALSE),                                   agencias=agencias_uf%>%                                   mutate(                                   custo_fixo=10000*12),                                   n_entrevistadores_min=2,                                   remuneracao_entrevistador=12*params$remuneracao_entrevistador                                 ))),           descricao='mínimo 2 entrevistadores /2 Técnicos (10000 p/ mes custo fixo), reorganizacao jurisdicao'),   tibble(params_carga=list(modifyList(params_carga_0,                                  list(                                   valor_diaria=params$valor_diaria*2,                                   distancias_ucs=params_carga_0$distancias_ucs,                                   agencias=agencias_uf%>%                                   mutate(                                   custo_fixo=10000*12),                                   n_entrevistadores_min=2,                                   remuneracao_entrevistador=12*params$remuneracao_entrevistador                                 ))),           descricao='mínimo de 2 entrevistadores/2 Técnicos 10000 p/ mes (custo fixo)/ custo diaria 2x') )%>%   #ungroup%>%slice(-1)%>%   mutate(resultado=purrr::map(params_carga, ~do.call(alocar_municipios, .x))) #toc()  estrategias_carga_sum <-    estrategias_carga%>%   rowwise(descricao)%>%   reframe(     bind_rows(       resultado$resultado_agencias_otimo%>%mutate(modelo=\"Ótimo\"),       resultado$resultado_agencias_jurisdicao%>%mutate(modelo=\"Jurisdição\"))%>%       group_by(modelo)%>%       mutate(n_agencias=1)%>%       summarise(across(matches(\"custo|n_agencias\"), ~sum(.x, na.rm=TRUE))))%>%   mutate(custo_total=custo_deslocamento+custo_fixo+custo_total_entrevistadores)%>%   select(descricao, modelo, n_agencias, custo_total, everything()) #report_plans(estrategias_carga$resultado[[1]])  estrategias_carga_sum%>%   group_by(descricao)%>%   arrange(descricao, modelo)%>%   select(-modelo)%>%   summarise(across(everything(), diff))%>%   arrange(desc(n_agencias), custo_total)%>%   select(descricao, n_agencias, custo_total, custo_total_entrevistadores, custo_diarias, custo_combustivel)%>%   #arrange(-custo_total)%>%   gt::gt()%>%   gt::cols_label(descricao='Modelo')%>%   gt::tab_caption(\"Redução de custos promovido pela otimização da rede de coleta\")%>%   print_gt()"},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"conclusão","dir":"Articles","previous_headings":"Estudos de caso","what":"Conclusão","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"otimização da rede de coleta promovida pelo pacote orce tem um impacto significativo na redução de custos, principalmente pela diminuição dos custos fixos associados às agências. estratégia mais eficaz envolve combinação da redução número de agências, imposição de limites de UPAs por agência e reorganização da jurisdição, e é provavelmente vantajoso (impor o limite) para boa gestão da coleta. É importante ressaltar que otimização deve considerar não apenas os custos, mas também outros fatores como qualidade dos dados coletados e capacidade operacional das agências. O pacote orce oferece flexibilidade para ajustar os parâmetros e restrições modelo, permitindo encontrar solução que melhor se adapta às necessidades e particularidades de cada pesquisa.","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"apêndice-detalhes-técnicos-do-problema-de-otimização","dir":"Articles","previous_headings":"Estudos de caso","what":"Apêndice: Detalhes técnicos do problema de otimização","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Este apêndice detalha o problema de otimização que o pacote orce resolve, que é alocação ideal de Unidades de Coleta (UCs) às agências, com o objetivo de minimizar os custos totais, incluindo custos de deslocamento e custos fixos de cada agência. O modelo de otimização é baseado problema clássico de localização de armazéns, e é baseado em “Warehouse Location Problem”, de Dirk Schumacher.","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"o-desafio","dir":"Articles","previous_headings":"Estudos de caso > Apêndice: Detalhes técnicos do problema de otimização","what":"O Desafio","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Dadas localizações das UCs e das agências, tarefa é decidir quais agências serão utilizadas e como UPAs serão distribuídas entre elas. Em outras palavras, precisamos decidir simultaneamente: Quais agências treinar/contratar. Como alocar UC cada agência. Começamos com um conjunto de UCs U={1…n}U = \\{1 \\ldots n\\} e um conjunto de agências potenciais ={1…m}= \\{1 \\ldots m\\} que poderiam ser ativadas. Também temos uma função de custo que fornece o custo de viagem de uma agência para uma UC. Além disso, há um custo fixo (incluindo custos de treinamento, entre outros) associado cada agência, caso ela seja selecionada para coleta de dados. Agências com um pequeno número de UCs podem ser inviáveis. Agências interior com um grande número de UCs também podem ser inviáveis. solução deve ter pelo menos min_upas e máximo max_upas por agência ativada. Observe que, ao permitir coleta “semi-centralizada”, não há limite para o número de UCs nas agências listadas. Para modelar essa situação, usamos duas variáveis de decisão: xi,jx_{,j}: uma variável binária que assume o valor 1 se UC ii alocada à agência jj e 0 caso contrário. yjy_j: uma variável binária que assume o valor 1 se agência jj selecionada para realizar coleta e 0 caso contrário. $$ \\begin{array}{ll@{}ll} \\text{minimizar} & \\displaystyle\\sum\\limits_{=1}^{n}\\sum\\limits_{j=1}^{m} custo\\_de\\_viagem_{,j} \\cdot x_{, j} + \\sum\\limits_{j=1}^{m} custo\\_fixo_{j} \\cdot y_{j}& &\\\\ \\text{sujeito } & \\displaystyle\\sum\\limits_{j=1}^{m} x_{, j} = 1 & =1 ,\\ldots, n&\\\\ & \\displaystyle x_{, j} \\leq y_j, & =1 ,\\ldots, n & j=1 ,\\ldots, m\\\\ & x_{,j} \\\\{0,1\\} &=1 ,\\ldots, n, & j=1 ,\\ldots, m \\\\ & y_{j} \\\\{0,1\\} &j=1 ,\\ldots, m& \\\\ & \\operatorname{(opcional)} \\sum\\limits_{=1}^{n}{x}_{,j} >= ( \\operatorname{min\\_upas} \\cdot y_{j}) & j=1 ,\\ldots, m& \\\\ & \\operatorname{(opcional)} \\sum\\limits_{=1}^{n}{x}_{,j} <= \\operatorname{max\\_upas}_{j} & j=1 ,\\ldots, m& \\end{array} $$ Explicação: Função Objetivo: Minimizar o custo total, que é soma dos custos de viagem para cada UC alocada uma agência e dos custos fixos de cada agência ativada. Cada UC deve ser alocada exatamente uma agência. Uma agência só pode receber UCs se estiver ativa. Opcional: Cada agência ativada deve ter pelo menos min_upas UCs alocadas. Opcional: Cada agência ativada deve ter máximo max_upas UCs alocadas. Variáveis de Decisão: x[, j]: Indica se UC é alocada à agência j (1 se sim, 0 se não). y[j]: Indica se agência j está ativa (1 se sim, 0 se não). Este modelo matemático representa o problema de alocação ótima e é resolvido pelo pacote orce para encontrar solução que minimiza os custos totais, considerando restrições e os custos específicos de cada cenário.","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce.html","id":"apêndice-função-principal-alocar_ucs","dir":"Articles","previous_headings":"Estudos de caso","what":"Apêndice: Função principal: alocar_ucs","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"função alocar_ucs realiza alocação otimizada de Unidades de Coleta (UCs) às agências, buscando minimizar os custos totais de deslocamento e operação. O processo de otimização considera diversas variáveis e restrições para encontrar solução mais eficiente. Entradas da Função uc: código único da UC agencia_codigo: código da agência à qual UC está atualmente alocada dias_coleta: número de dias de coleta na UC viagens: número de viagens necessárias para coleta na UC agencia_codigo: código único da agência custo_litro_combustivel: custo combustível por litro custo_hora_viagem: custo por hora de viagem kml: consumo médio de combustível veículo (km/l) valor_diaria: valor da diária custo_fixo: custo fixo mensal da agência dias_treinamento: número de dias/diárias para treinamento adicional_troca_jurisdicao: custo adicional por troca de jurisdição min_uc_agencia: número mínimo de UCs por agência (exceto agências treinadas) max_uc_agencia: número máximo de UCs por agência semi_centralizada: vetor com códigos de agências sem limite máximo de UCs agencias_treinadas: vetor com códigos de agências já treinadas (sem custo de treinamento) agencias_treinamento: código da(s) agência(s) de treinamento distancias_ucs: distâncias entre UCs e agências, contendo: uc, agencia_codigo, duracao_horas, diaria_municipio, diaria_pernoite distancias_agencias: distâncias entre agências resultado_completo: se TRUE, retorna informações adicionais sobre todas combinações de UCs e agências Processamento Interno Verifica se os argumentos de entrada são válidos Define o número máximo de UCs por agência, se não fornecido Cria alocação por jurisdição (se agencias não fornecido, assume agências das UCs) Seleciona agência de treinamento mais próxima para cada agência de coleta Calcula os custos de treinamento com base na distância e se agência já foi treinada Combina informações de UCs e agências em um formato adequado para otimização Calcula os custos de transporte (combustível, tempo de viagem, diárias) para cada combinação de UC e agência Utiliza o pacote ompr para criar um modelo de otimização x[, j]: 1 se UC alocada à agência j, 0 caso contrário y[j]: 1 se agência j incluída na solução, 0 caso contrário Define função objetivo: minimizar o custo total (deslocamento + custos fixos das agências + custos de treinamento) Cada UC deve ser alocada exatamente uma agência Se uma UC é alocada uma agência, agência deve estar ativa Restrições de número mínimo e máximo de UCs por agência (se aplicável) Resolve o modelo usando o solver GLPK Extrai solução ótima: quais UCs são alocadas quais agências Cria tabelas com os resultados da alocação ótima e da alocação original (por jurisdição), tanto para UCs quanto para agências Se resultado_completo TRUE, retorna também um tibble com todas combinações de UCs e agências e seus respectivos custos Saídas da Função resultado_ucs_otimo: alocação ótima das UCs e seus custos resultado_ucs_jurisdicao: alocação original das UCs e seus custos resultado_agencias_otimo: alocação ótima das agências, custos e número de UCs alocadas resultado_agencias_jurisdicao: alocação original das agências, custos e número de UCs alocadas ucs_agencias_todas (opcional): todas combinações de UCs e agências e seus custos Observações O cálculo de diárias já considera jurisdição, microrregiões, áreas metropolitanas e distância/necessidade de pernoite. flexibilidade pacote permite ajustar os parâmetros e restrições para atender às necessidades específicas planejamento da coleta de dados.","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce_presentation.html","id":"resumo","dir":"Articles","previous_headings":"","what":"Resumo","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"O pacote R ‘orce’ é uma ferramenta para otimizar alocação de Unidades de Coleta (UCs) em pesquisas IBGE, visando minimizar os custos totais de coleta. Principais características: Usa programação linear inteira mista Considera fatores como distâncias, tempo de viagem, custos fixos e diárias Estudos de caso mostram reduções de até 40% nos custos Permite melhor balanceamento da carga de trabalho entre agências Flexível para se adaptar diferentes pesquisas","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce_presentation.html","id":"introdução","dir":"Articles","previous_headings":"","what":"Introdução","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Otimização de custos é um desafio para instituições de pesquisa IBGE deve otimizar alocação de setores censitários, escolas, empresas às agências Pacote ‘orce’ otimiza alocação de Unidades de Coleta (UCs) às agências IBGE Crucial para coleta econômica e eficaz em pesquisas de grande escala","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce_presentation.html","id":"principais-características-do-orce","dir":"Articles","previous_headings":"","what":"Principais Características do ‘orce’","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Roteamento e Geocodificação Otimização Avançada da Alocação Cálculo de Custos Detalhados Flexibilidade e Adaptabilidade","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce_presentation.html","id":"roteamento-e-geocodificação","dir":"Articles","previous_headings":"","what":"Roteamento e Geocodificação","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Função ponto_densidade identifica locais representativos em setores censitários Prioriza áreas de alta densidade populacional Facilita acesso e garante destinos/origens válidos para algoritmo de roteamento Aprendizado: Nunca utilize centróides!","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce_presentation.html","id":"otimização-avançada-da-alocação","dir":"Articles","previous_headings":"","what":"Otimização Avançada da Alocação","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Algoritmo distribui UCs entre agências Considera distância, tempo de viagem, custos fixos, diárias Funções alocar_ucs e alocar_municipios permitem personalização Adapta-se às necessidades específicas de cada projeto","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce_presentation.html","id":"cálculo-de-custos-detalhados","dir":"Articles","previous_headings":"","what":"Cálculo de Custos Detalhados","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Considera fronteiras administrativas (jurisdição das agências, microrregiões, regiões metropolitanas) para cálculo de diárias Inclui custos de combustível e tempo de viagem Fornece estimativa completa dos gastos de coleta","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce_presentation.html","id":"flexibilidade-e-adaptabilidade","dir":"Articles","previous_headings":"","what":"Flexibilidade e Adaptabilidade","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Custo de combustível, consumo por quilômetro rodado, custo por hora de viagem Valor da diária e da remuneração dos entrevistadores (Agentes de Pesquisa e Mapeamento) Custo fixo por agência (e.g. Técnicos) Carga de trabalho máxima por agência e por entrevistador. Máximo de diárias por entrevistador Adaptável diferentes tipos de pesquisas e necessidades","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce_presentation.html","id":"impacto-e-aplicações","dir":"Articles","previous_headings":"","what":"Impacto e Aplicações","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Redução de custos de viagem e tempo de deslocamento Otimização da utilização dos recursos das agências Facilita planejamento e gestão da coleta de dados","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce_presentation.html","id":"estudo-de-caso-1-munic-no-espírito-santo","dir":"Articles","previous_headings":"","what":"Estudo de Caso 1: MUNIC no Espírito Santo","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"78 municípios, 10 agências IBGE Diárias conforme microrregião/região metropolitana Tempo de viagem > 1,5 horas = diária Coleta presencial de 2 dias Pernoite = 1,5 diárias, 1 viagem Sem pernoite = 2 viagens, meia-diária em alguns casos Veículos IBGE: 10 km/l, combustível R$ 6/l","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce_presentation.html","id":"resultados-da-otimização-munic---es","dir":"Articles","previous_headings":"","what":"Resultados da Otimização MUNIC - ES","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Economia de 8% valor das diárias Mesmo valor em combustível 4 alterações de agência de coleta","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce_presentation.html","id":"estudo-de-caso-2-pof-2024-25-na-bahia","dir":"Articles","previous_headings":"","what":"Estudo de Caso 2: POF 2024-25 na Bahia","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Considerações: - Mínimo de 2 entrevistadores por agência - 200 dias de trabalho por entrevistador/ano - 10 dias de coleta por Unidade Primária de Amostragem - 10 idas e voltas para setores sem pernoite, 2 para casos com pernoite","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce_presentation.html","id":"impacto-da-otimização-pof---ba","dir":"Articles","previous_headings":"","what":"Impacto da Otimização POF - BA","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Maior economia ao incluir custos de treinamento e remuneração dos entrevistadores Redução significativa número de agências","code":""},{"path":"https://leoniedu.github.io/orce/articles/orce_presentation.html","id":"caso-3-otimizando-a-jurisdição-de-agências","dir":"Articles","previous_headings":"","what":"Caso 3: Otimizando a jurisdição de agências","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"Pesquisas incluídas: - Pesquisas da Amostra Mestra (Domiciliares): PNADC, CNEFE, POF - Pesquisas Municipais: duas visitas anuais por município","code":""},{"path":[]},{"path":"https://leoniedu.github.io/orce/articles/orce_presentation.html","id":"funções-de-alocação","dir":"Articles","previous_headings":"","what":"Funções de alocação","title":"Otimizando a Coleta de Dados do IBGE com o Pacote R 'orce'","text":"alocar_ucs Entradas: - Dados das UCs e Agências - Parâmetros de custo - Restrições de alocação - Dados de distância Processamento: 1. Pré-processamento 2. Modelagem da otimização 3. Solução da otimização 4. Pós-processamento Saídas: - Alocações ótimas e originais (UCs e agências) - Custos detalhados - Combinações completas (opcional) alocar_municipios Diferença em relação alocar_ucs é que unidades de coleta de um mesmo município são alocadas uma só agência.","code":""},{"path":"https://leoniedu.github.io/orce/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Eduardo Leoni. Author, maintainer.","code":""},{"path":"https://leoniedu.github.io/orce/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Leoni E (2024). orce: orce: Otimização de Redes de Coleta Estatística. R package version 0.0.0.9000, https://leoniedu.github.io/orce/.","code":"@Manual{,   title = {orce: orce: Otimização de Redes de Coleta Estatística},   author = {Eduardo Leoni},   year = {2024},   note = {R package version 0.0.0.9000},   url = {https://leoniedu.github.io/orce/}, }"},{"path":[]},{"path":"https://leoniedu.github.io/orce/index.html","id":"english","dir":"","previous_headings":"","what":"English","title":"orce: Otimização de Redes de Coleta Estatística","text":"orce package R package designed optimize allocation primary sampling units (PSUs), census tracts health facilities, IBGE (Brazilian Institute Geography Statistics) agencies. allocation process crucial efficient cost-effective data collection large-scale surveys censuses. package addresses several challenges inherent process, including: Routing Geocoding: Determining optimal routes PSUs agencies requires accurate location data. orce package leverages CNEFE (National Register Addresses Statistical Purposes) database obtain precise coordinates PSU, prioritizing high-density areas within census tracts ensure accessibility representativeness. ponto_setor_densidade function aids identifying representative locations. Allocation Optimization: core orce package allocation optimization algorithm. employs mixed-integer linear programming minimize overall cost data collection, considering factors like travel distances, travel time, fixed agency costs. alocar_upas function implements optimization, allowing flexible constraints agency capacity location preferences. Cost Calculation: Accurately estimating cost data collection involves just distances travel time. orce package incorporates knowledge administrative boundaries determine whether “diárias” (travel allowances) applicable. nuanced cost calculation ensures optimization results reflect true financial implications different allocation scenarios. Flexibility Adaptability: orce package offers various customization options accommodate specific needs different surveys data collection efforts. Users can define parameters fuel costs, hourly travel costs, vehicle fuel efficiency, agency-specific constraints. summary, orce package provides powerful versatile solution optimizing allocation PSUs IBGE agencies. addressing challenges related routing, geocoding, allocation optimization, cost calculation, enables efficient cost-effective data collection strategies. flexibility adaptability make valuable tool wide range survey census operations Brazil.","code":""},{"path":"https://leoniedu.github.io/orce/index.html","id":"português","dir":"","previous_headings":"","what":"Português","title":"orce: Otimização de Redes de Coleta Estatística","text":"O pacote orce é um pacote R projetado para otimizar alocação de unidades primárias de amostragem (UPAs), como setores censitários ou estabelecimentos de saúde, às agências IBGE (Instituto Brasileiro de Geografia e Estatística). Esse processo de alocação é crucial para coleta de dados eficiente e econômica em pesquisas e censos de grande escala. O pacote aborda vários desafios inerentes esse processo, incluindo: Roteamento e Geocodificação: determinação das rotas ideais entre UPAs e agências requer dados de localização precisos. O pacote orce utiliza o banco de dados CNEFE (Cadastro Nacional de Endereços para Fins Estatísticos) para obter coordenadas precisas para cada UPA, priorizando áreas de alta densidade dentro dos setores censitários para garantir acessibilidade e representatividade. função ponto_setor_densidade auxilia na identificação desses locais representativos. Otimização da Alocação: O núcleo pacote orce é seu algoritmo de otimização de alocação. Ele emprega programação linear inteira mista para minimizar o custo total da coleta de dados, considerando fatores como distâncias de viagem, tempo de viagem e custos fixos das agências. função alocar_upas implementa essa otimização, permitindo restrições flexíveis na capacidade da agência e nas preferências de localização. Cálculo de Custos: Estimar com precisão o custo da coleta de dados envolve mais que apenas distâncias e tempo de viagem. O pacote orce incorpora o conhecimento das fronteiras administrativas para determinar se “diárias” (ajudas de custo para viagens) são aplicáveis. Esse cálculo de custo diferenciado garante que os resultados da otimização reflitam verdadeiras implicações financeiras de diferentes cenários de alocação. Flexibilidade e Adaptabilidade: O pacote orce oferece várias opções de personalização para acomodar necessidades específicas de diferentes pesquisas e esforços de coleta de dados. Os usuários podem definir parâmetros como custos de combustível, custos de viagem por hora, eficiência de combustível veículo e restrições específicas da agência. Em resumo, o pacote orce fornece uma solução poderosa e versátil para otimizar alocação de UPAs às agências IBGE. Ao abordar os desafios relacionados ao roteamento, geocodificação, otimização de alocação e cálculo de custos, ele permite estratégias de coleta de dados eficientes e econômicas. Sua flexibilidade e adaptabilidade o tornam uma ferramenta valiosa para uma ampla gama de operações de pesquisa e censo Brasil.","code":""},{"path":"https://leoniedu.github.io/orce/reference/ToTitleCasePT.html","id":null,"dir":"Reference","previous_headings":"","what":"Convertion to title case with lower case for some classes of words. — ToTitleCasePT","title":"Convertion to title case with lower case for some classes of words. — ToTitleCasePT","text":"written Portuguese, converting title case, usual keep title case words, like prepositions, conjunctions, articles kinds pronouns.  functions locates cases converts lower case. Based gist ToTitleCasePT https://gist.github.com/jjesusfilho/454192db8356eb9c486a02698338221a https://github.com/jjesusfilho","code":""},{"path":"https://leoniedu.github.io/orce/reference/ToTitleCasePT.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convertion to title case with lower case for some classes of words. — ToTitleCasePT","text":"","code":"ToTitleCasePT(string, ...)"},{"path":"https://leoniedu.github.io/orce/reference/ToTitleCasePT.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convertion to title case with lower case for some classes of words. — ToTitleCasePT","text":"string vector characters converted title case connector words (one-word prepositions conjunctions) articles (definite indefinite) pronouns lower case.","code":""},{"path":"https://leoniedu.github.io/orce/reference/ToTitleCasePT.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convertion to title case with lower case for some classes of words. — ToTitleCasePT","text":"vector characters dimension string","code":""},{"path":"https://leoniedu.github.io/orce/reference/ToTitleCasePT.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convertion to title case with lower case for some classes of words. — ToTitleCasePT","text":"current list words converted lower case : articles o(s), (s), um, uma(s), uns pronouns , mim, meu(s), minha(s) te, ti, teu(s), tua(s) lhe(s), seu(s), sua(s) nos, nosso()(s) vos, vosso()(s) prepositions, contractions combinations prepositions , ante, até, após, com, contra, de, desde, em, entre, para, perante, por, sem, sob, sobre, trás contractions à(s), ()(s), ()(s), pelo()(s), pro()(s) (informal language) combinations ao(s) conjunctions conforme, conquanto, contudo, durante, embora, enquanto, então, entretanto, exceto, logo, mas, nem, ou, ora, pois, porém, porque, porquanto, portanto, quando, quanto, que, se, senão, todavia list far complete exaustive, mainly due absence accidental prepositions conjuntions, words originally prepositions conjunctions, can play roles contexts, like, instance segundo, can mean either numeral second prepositional expression acording .","code":""},{"path":"https://leoniedu.github.io/orce/reference/add_coordinates.html","id":null,"dir":"Reference","previous_headings":"","what":"Add Coordinates to an sf Object — add_coordinates","title":"Add Coordinates to an sf Object — add_coordinates","text":"function extracts coordinates sf object's geometry adds new columns object.","code":""},{"path":"https://leoniedu.github.io/orce/reference/add_coordinates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add Coordinates to an sf Object — add_coordinates","text":"","code":"add_coordinates(sf_object, lon = \"lon\", lat = \"lat\")"},{"path":"https://leoniedu.github.io/orce/reference/add_coordinates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add Coordinates to an sf Object — add_coordinates","text":"sf_object sf object containing spatial features. lon string specifying name longitude column. Defaults \"lon\". lat string specifying name latitude column. Defaults \"lat\".","code":""},{"path":"https://leoniedu.github.io/orce/reference/add_coordinates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add Coordinates to an sf Object — add_coordinates","text":"sf object added coordinate columns.","code":""},{"path":"https://leoniedu.github.io/orce/reference/add_coordinates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add Coordinates to an sf Object — add_coordinates","text":"","code":"# Load necessary packages library(sf) library(dplyr)  # Create a simple sf object points <- data.frame(   name = c(\"A\", \"B\"),   geometry = c(\"POINT(1 2)\", \"POINT(3 4)\") ) %>%   st_as_sf(wkt = \"geometry\")  # Add coordinates using default column names points_with_coords <- add_coordinates(points)  # Add coordinates using custom column names points_with_coords_custom <- add_coordinates(points, lon = \"longitude\", lat = \"latitude\")"},{"path":"https://leoniedu.github.io/orce/reference/alocar_municipios.html","id":null,"dir":"Reference","previous_headings":"","what":"Alocação Otimizada de Municípios a Agências — alocar_municipios","title":"Alocação Otimizada de Municípios a Agências — alocar_municipios","text":"Esta função realiza alocação otimizada de Municípios agências, com o objetivo de minimizar os custos totais de deslocamento e operação. alocação leva em consideração restrições de capacidade das agências, custos de deslocamento (combustível, tempo de viagem e diárias), custos fixos das agências, custos de treinamento e o número de entrevistadores necessários.","code":""},{"path":"https://leoniedu.github.io/orce/reference/alocar_municipios.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Alocação Otimizada de Municípios a Agências — alocar_municipios","text":"","code":"alocar_municipios(   ucs,   agencias = data.frame(agencia_codigo = unique(ucs$agencia_codigo),     dias_coleta_agencia_max = Inf, custo_fixo = 0),   custo_litro_combustivel = 6,   custo_hora_viagem = 10,   kml = 10,   valor_diaria = 335,   diarias_entrevistador_max = Inf,   remuneracao_entrevistador = 0,   n_entrevistadores_min = 1,   dias_coleta_entrevistador_max,   dias_treinamento = 0,   agencias_treinadas = NULL,   agencias_treinamento = NULL,   distancias_ucs,   distancias_agencias = NULL,   adicional_troca_jurisdicao = 0,   resultado_completo = FALSE,   solver = \"cbc\",   rel_tol = 0.02,   max_time = 30 * 60,   ... )"},{"path":"https://leoniedu.github.io/orce/reference/alocar_municipios.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Alocação Otimizada de Municípios a Agências — alocar_municipios","text":"ucs Uma data.frame contendo informações sobre UCs, incluindo: uc: Código único da UC. municipio_codigo: Código único município. agencia_codigo: Código da agência à qual UC está atualmente alocada. dias_coleta: Número de dias de coleta na UC. viagens: Número de viagens necessárias para coleta na UC. agencias Uma data.frame contendo informações sobre agências selecionáveis, incluindo: agencia_codigo: Código único da agência. custo_fixo: Custo fixo associado à agência. dias_coleta_agencia_max: Número máximo de dias de coleta que agência pode realizar. custo_litro_combustivel Custo combustível por litro (em R$). Padrão: 6. custo_hora_viagem Custo de cada hora de viagem (em R$). Padrão: 10. kml Consumo médio de combustível veículo (em km/l). Padrão: 10. valor_diaria Valor da diária para deslocamentos (em R$). Padrão: 335. diarias_entrevistador_max Máximo de diárias que um entrevistador pode receber período de referência. Padrão: Inf. remuneracao_entrevistador Remuneração por entrevistador para todo o período de referência. Padrão: 0. n_entrevistadores_min Número mínimo de entrevistadores por agência. Padrão: 1. dias_coleta_entrevistador_max Número de dias de coleta por entrevistador. dias_treinamento Número de dias/diárias para treinamento. Padrão: 0 (nenhum treinamento). agencias_treinadas (Opcional) Um vetor de caracteres com os códigos das agências que já foram treinadas e não terão custo de treinamento. Padrão: NULL. agencias_treinamento Código da(s) agência(s) onde o treinamento será realizado. distancias_ucs Uma data.frame com distâncias entre UCs e agências, incluindo: uc: Código da UC. municipio_codigo: Código município onde UC está localizada. agencia_codigo: Código da agência. distancia_km: Distância em quilômetros entre UC e agência. duracao_horas: Duração da viagem em horas entre UC e agência. diaria_municipio: Indica se é necessária uma diária para deslocamento entre UC e agência, considerando o município da UC. diaria_pernoite: Indica se é necessária uma diária com pernoite para deslocamento entre UC e agência. distancias_agencias Uma data.frame com distâncias entre agências, incluindo: agencia_codigo_orig: Código da agência de origem. agencia_codigo_dest: Código da agência de destino. distancia_km: Distância em quilômetros entre agência de origem e de destino. duracao_horas: Duração da viagem em horas entre agência de origem e de destino. adicional_troca_jurisdicao Custo adicional quando há troca de agência de coleta. Padrão: 0. resultado_completo (Opcional) Um valor lógico indicando se deve ser retornado um resultado mais completo, incluindo informações sobre todas combinações de UCs e agências. Padrão: FALSE. solver Qual ferramenta para solução modelo de otimização utilizar. Padrão: \"cbc\". Outras opções: \"glpk\", \"symphony\" (instalação manual). rel_tol Tolerância relativa para otimização. Valores menores levam soluções mais precisas, mas podem aumentar o tempo de execução. Padrão: 0.02 max_time Tempo máximo de execução (em segundos) permitido para o solver. Padrão: 30*60 (30 minutos) ... Opções adicionais para o solver. uc_agencia_min Número mínimo de UCs por agência que incluída. Padrão: 1","code":""},{"path":"https://leoniedu.github.io/orce/reference/alocar_municipios.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Alocação Otimizada de Municípios a Agências — alocar_municipios","text":"Uma lista contendo: resultado_municipios_jurisdicao: Um tibble com os municipios e suas alocações originais (jurisdição), incluindo custos de deslocamento. resultado_agencias_jurisdicao: Um tibble com agências e suas alocações originais (jurisdição), incluindo custos fixos, custos de deslocamento e número de UCs alocadas. resultado_municipios_otimo: Um tibble com os municípios e suas alocações otimizadas, incluindo custos de deslocamento. resultado_agencias_otimo: Um tibble com agências e suas alocações otimizadas, incluindo custos fixos, custos de deslocamento, número de UCs alocadas e número de entrevistadores. municipios_agencias_todas (opcional): Um tibble com todas combinações de municípios e agências, incluindo distâncias, custos e informações sobre diárias (retornado apenas se resultado_completo TRUE). otimizacao (opcional): O resultado completo da otimização (retornado apenas se resultado_completo TRUE).","code":""},{"path":"https://leoniedu.github.io/orce/reference/alocar_ucs.html","id":null,"dir":"Reference","previous_headings":"","what":"Alocação Otimizada de Unidades de Coleta (UCs) a Agências — alocar_ucs","title":"Alocação Otimizada de Unidades de Coleta (UCs) a Agências — alocar_ucs","text":"Esta função realiza alocação otimizada de Unidades de Coleta (UCs) agências, com o objetivo de minimizar os custos totais de deslocamento e operação. alocação leva em consideração restrições de capacidade das agências (em número de dias de coleta), custos de deslocamento (combustível, tempo de viagem e diárias), custos fixos das agências e custos de treinamento.","code":""},{"path":"https://leoniedu.github.io/orce/reference/alocar_ucs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Alocação Otimizada de Unidades de Coleta (UCs) a Agências — alocar_ucs","text":"","code":"alocar_ucs(   ucs,   agencias = data.frame(agencia_codigo = unique(ucs$agencia_codigo),     dias_coleta_agencia_max = Inf, custo_fixo = 0),   custo_litro_combustivel = 6,   custo_hora_viagem = 10,   kml = 10,   valor_diaria = 335,   diarias_entrevistador_max = Inf,   remuneracao_entrevistador = 0,   n_entrevistadores_min = 1,   dias_coleta_entrevistador_max,   dias_treinamento = 0,   agencias_treinadas = NULL,   agencias_treinamento = NULL,   distancias_ucs,   distancias_agencias = NULL,   adicional_troca_jurisdicao = 0,   resultado_completo = FALSE,   solver = \"cbc\",   rel_tol = 0.02,   max_time = 30 * 60,   ... )"},{"path":"https://leoniedu.github.io/orce/reference/alocar_ucs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Alocação Otimizada de Unidades de Coleta (UCs) a Agências — alocar_ucs","text":"ucs Um tibble ou data.frame contendo informações sobre UCs, incluindo: uc: Código único da UC. agencia_codigo: Código da agência à qual UC está atualmente alocada. dias_coleta: Número de dias de coleta na UC. viagens: Número de viagens necessárias para coleta na UC. agencias Um tibble ou data.frame contendo informações sobre agências selecionáveis, incluindo: agencia_codigo: Código único da agência. dias_coleta_agencia_max: Número máximo de dias de coleta que agência pode realizar. custo_fixo: Custo fixo associado à agência. custo_litro_combustivel Custo combustível por litro (em R$). Padrão: 6. custo_hora_viagem Custo de cada hora de viagem (em R$). Padrão: 10. kml Consumo médio de combustível veículo (em km/l). Padrão: 10. valor_diaria Valor da diária para deslocamentos (em R$). Padrão: 335. diarias_entrevistador_max Máximo de diárias que um entrevistador pode receber período de referência. Padrão: Inf. remuneracao_entrevistador Remuneração por entrevistador para todo o período de referência. Padrão: 0. n_entrevistadores_min Número mínimo de entrevistadores por agência. Padrão: 1. dias_coleta_entrevistador_max Número de dias de coleta por entrevistador. dias_treinamento Número de dias/diárias para treinamento. Padrão: 0 (nenhum treinamento). agencias_treinadas (Opcional) Um vetor de caracteres com os códigos das agências que já foram treinadas e não terão custo de treinamento. Padrão: NULL. agencias_treinamento Código da(s) agência(s) onde o treinamento será realizado. distancias_ucs Um tibble ou data.frame com distâncias entre UCs e agências, incluindo: uc: Código da UC. agencia_codigo: Código da agência. distancia_km: Distância em quilômetros entre UC e agência. duracao_horas: Duração da viagem em horas entre UC e agência. diaria_municipio: Indica se é necessária uma diária para deslocamento entre UC e agência, considerando o município da UC. diaria_pernoite: Indica se é necessária uma diária com pernoite para deslocamento entre UC e agência. distancias_agencias Um tibble ou data.frame com distâncias entre agências, incluindo: agencia_codigo_orig: Código da agência de origem. agencia_codigo_dest: Código da agência de destino. distancia_km: Distância em quilômetros entre agência de origem e de destino. duracao_horas: Duração da viagem em horas entre agência de origem e de destino. adicional_troca_jurisdicao Custo adicional quando há troca de agência de coleta. Padrão: 0. resultado_completo (Opcional) Um valor lógico indicando se deve ser retornado um resultado mais completo, incluindo informações sobre todas combinações de UCs e agências. Padrão: FALSE. solver Qual ferramenta para solução modelo de otimização utilizar. Padrão: \"cbc\". Outras opções: \"glpk\", \"symphony\" (instalação manual). ... Opções adicionais para o solver.","code":""},{"path":"https://leoniedu.github.io/orce/reference/alocar_ucs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Alocação Otimizada de Unidades de Coleta (UCs) a Agências — alocar_ucs","text":"Uma lista contendo: resultado_ucs_jurisdicao: Um tibble com UCs e suas alocações originais (jurisdição), incluindo custos de deslocamento. resultado_agencias_jurisdicao: Um tibble com agências e suas alocações originais (jurisdição), incluindo custos fixos, custos de deslocamento e número de UCs alocadas. resultado_ucs_otimo: Um tibble com UCs e suas alocações otimizadas, incluindo custos de deslocamento. resultado_agencias_otimo: Um tibble com agências e suas alocações otimizadas, incluindo custos fixos, custos de deslocamento, número de UCs alocadas e número de entrevistadores. ucs_agencias_todas (opcional): Um tibble com todas combinações de UCs e agências, incluindo distâncias, custos e informações sobre diárias (retornado apenas se resultado_completo TRUE). otimizacao (opcional): O resultado completo da otimização (retornado apenas se resultado_completo TRUE).","code":""},{"path":"https://leoniedu.github.io/orce/reference/calcula_diarias.html","id":null,"dir":"Reference","previous_headings":"","what":"Calcula o Número de Diárias — calcula_diarias","title":"Calcula o Número de Diárias — calcula_diarias","text":"Esta função calcula o número de diárias serem pagas para um deslocamento, considerando o número de dias e se diária inclui pernoite.","code":""},{"path":"https://leoniedu.github.io/orce/reference/calcula_diarias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calcula o Número de Diárias — calcula_diarias","text":"","code":"calcula_diarias(dias, meia_diaria)"},{"path":"https://leoniedu.github.io/orce/reference/calcula_diarias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calcula o Número de Diárias — calcula_diarias","text":"dias Número de dias deslocamento. meia_diaria Valor lógico indicando se diária é de apenas meio dia (TRUE) ou dia inteiro (FALSE).","code":""},{"path":"https://leoniedu.github.io/orce/reference/calcula_diarias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calcula o Número de Diárias — calcula_diarias","text":"O número de diárias serem pagas.","code":""},{"path":"https://leoniedu.github.io/orce/reference/calcula_diarias.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calcula o Número de Diárias — calcula_diarias","text":"","code":"calcula_diarias(dias = 2, meia_diaria = FALSE) # Retorna 1.5 #> [1] 1,5 calcula_diarias(dias = 2, meia_diaria = TRUE) # Retorna 1 #> [1] 1 calcula_diarias(dias = 5, meia_diaria = TRUE) # Retorna 2.5 #> [1] 2,5 calcula_diarias(dias = 5, meia_diaria = FALSE) # Retorna 4.5 #> [1] 4,5"},{"path":"https://leoniedu.github.io/orce/reference/calcula_distancias.html","id":null,"dir":"Reference","previous_headings":"","what":"Calcula Distâncias Entre Origens e Destinos — calcula_distancias","title":"Calcula Distâncias Entre Origens e Destinos — calcula_distancias","text":"Esta função calcula distância e duração entre conjuntos de pontos de origem e destino usando o serviço OSRM.","code":""},{"path":"https://leoniedu.github.io/orce/reference/calcula_distancias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calcula Distâncias Entre Origens e Destinos — calcula_distancias","text":"","code":"calcula_distancias(destinos, origens, nmax = 2000)"},{"path":"https://leoniedu.github.io/orce/reference/calcula_distancias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calcula Distâncias Entre Origens e Destinos — calcula_distancias","text":"destinos Um objeto sf representando os pontos de destino. origens Um objeto sf representando os pontos de origem. nmax Número máximo de pares origem-destino para cada requisição ao serviço OSRM. Utilizado para evitar o limite de número de pares por requisição. Padrão: 2000.","code":""},{"path":"https://leoniedu.github.io/orce/reference/calcula_distancias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calcula Distâncias Entre Origens e Destinos — calcula_distancias","text":"Um data.frame com distâncias (em quilômetros) e durações (em horas) entre cada par de origem e destino, além dos atributos originais de origens e destinos.","code":""},{"path":"https://leoniedu.github.io/orce/reference/calcula_distancias.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calcula Distâncias Entre Origens e Destinos — calcula_distancias","text":"função utiliza o pacote osrm para calcular distâncias e durações entre os pontos de origem e destino. O parâmetro nmax permite dividir requisições ao serviço OSRM em lotes menores, evitando o erro \"many table coordinates\" que ocorre quando o número de pares origem-destino é muito grande.","code":""},{"path":"https://leoniedu.github.io/orce/reference/map_uc_agencias.html","id":null,"dir":"Reference","previous_headings":"","what":"Mapeia Unidades de Coleta (UCs) e Agências — map_uc_agencias","title":"Mapeia Unidades de Coleta (UCs) e Agências — map_uc_agencias","text":"Esta função cria um mapa exibindo localização das unidades de coleta (UCs) e agências. Ela utiliza o pacote ggmap para obter um mapa de uma fonte especificada (por exemplo, Google Maps) e sobrepõe UCs e agências nele.","code":""},{"path":"https://leoniedu.github.io/orce/reference/map_uc_agencias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mapeia Unidades de Coleta (UCs) e Agências — map_uc_agencias","text":"","code":"map_uc_agencias(   data,   f = 0.05,   source = \"google\",   maptype = \"roadmap\",   zoom = \"auto\" )"},{"path":"https://leoniedu.github.io/orce/reference/map_uc_agencias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mapeia Unidades de Coleta (UCs) e Agências — map_uc_agencias","text":"data Um data.frame contendo coordenadas das UCs e agências. Deve possuir colunas chamadas uc_lat, uc_lon, agencia_lat e agencia_lon. f Um valor numérico especificando fração pela qual expandir caixa delimitadora em torno das UCs e agências. Padrão: 0.05. source Uma string de caracteres especificando fonte mapa (e.g., \"google\", \"osm\", \"stamen\"). Veja documentação ggmap para mais detalhes. Padrão: \"google\". maptype Uma string de caracteres especificando o tipo de mapa (e.g., \"terrain\", \"toner\", \"watercolor\"). Veja documentação ggmap para mais detalhes. Padrão: \"roadmap\". zoom Um número inteiro ou string \"auto\" especificando o nível de zoom. Se \"auto\", o nível de zoom é calculado automaticamente para ajustar todas UCs e agências mapa.","code":""},{"path":"https://leoniedu.github.io/orce/reference/map_uc_agencias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mapeia Unidades de Coleta (UCs) e Agências — map_uc_agencias","text":"Um objeto ggmap representando o mapa com UCs e agências sobrepostas.","code":""},{"path":"https://leoniedu.github.io/orce/reference/ponto_densidade.html","id":null,"dir":"Reference","previous_headings":"","what":"Calcula o Ponto de Densidade de Unidades Espaciais — ponto_densidade","title":"Calcula o Ponto de Densidade de Unidades Espaciais — ponto_densidade","text":"Esta função calcula unidade com maior densidade populacional para cada unidade espacial (e.g., setor censitário, município) em um objeto sf, com base número de estabelecimentos (ou outro tipo de ponto) em cada unidade.","code":""},{"path":"https://leoniedu.github.io/orce/reference/ponto_densidade.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calcula o Ponto de Densidade de Unidades Espaciais — ponto_densidade","text":"","code":"ponto_densidade(cnefe, geoid)"},{"path":"https://leoniedu.github.io/orce/reference/ponto_densidade.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calcula o Ponto de Densidade de Unidades Espaciais — ponto_densidade","text":"cnefe Um objeto sf contendo geometria das unidades espaciais e o número de estabelecimentos em cada unidade. Deve conter uma coluna chamada n com o número de estabelecimentos e uma coluna com o código da unidade espacial, cujo nome é especificado argumento geoid. geoid O nome da coluna em cnefe que contém o código único da unidade espacial (e.g., \"cod_setor\", \"cod_municipio\").","code":""},{"path":"https://leoniedu.github.io/orce/reference/ponto_densidade.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calcula o Ponto de Densidade de Unidades Espaciais — ponto_densidade","text":"Um data.frame com o código da unidade espacial (geoid) e coordenadas ponto de maior densidade (latitude e longitude) para cada unidade.","code":""},{"path":"https://leoniedu.github.io/orce/reference/ponto_densidade.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calcula o Ponto de Densidade de Unidades Espaciais — ponto_densidade","text":"função utiliza o pacote spatstat para calcular densidade de pontos em cada unidade espacial. O ponto de densidade é definido como o ponto com maior densidade de pontos dentro da unidade. densidade é calculada usando um kernel gaussiano com largura de banda sigma definida como o máximo entre 10% da amplitude da unidade espacial e 30 metros.","code":""},{"path":"https://leoniedu.github.io/orce/reference/rename_ibge.html","id":null,"dir":"Reference","previous_headings":"","what":"Padroniza Nomes de Colunas para o Formato IBGE — rename_ibge","title":"Padroniza Nomes de Colunas para o Formato IBGE — rename_ibge","text":"Esta função padroniza os nomes das colunas de um data.frame para o formato utilizado pelo IBGE, utilizando um dicionário de nomes comuns e seus equivalentes padronizados.","code":""},{"path":"https://leoniedu.github.io/orce/reference/rename_ibge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Padroniza Nomes de Colunas para o Formato IBGE — rename_ibge","text":"","code":"rename_ibge(x)"},{"path":"https://leoniedu.github.io/orce/reference/rename_ibge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Padroniza Nomes de Colunas para o Formato IBGE — rename_ibge","text":"x Um data.frame com colunas serem renomeadas.","code":""},{"path":"https://leoniedu.github.io/orce/reference/rename_ibge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Padroniza Nomes de Colunas para o Formato IBGE — rename_ibge","text":"O data.frame com os nomes das colunas padronizados.","code":""},{"path":"https://leoniedu.github.io/orce/reference/rename_ibge.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Padroniza Nomes de Colunas para o Formato IBGE — rename_ibge","text":"função realiza seguintes etapas: Padroniza os nomes das colunas para minúsculas e remove caracteres especiais usando janitor::clean_names(). Renomeia colunas usando um dicionário pré-definido de nomes comuns e seus equivalentes padronizados. Substitui \"longitude\" por \"lon\" e \"latitude\" por \"lat\" nos nomes das colunas. Converte colunas que contêm códigos (e.g., cod_setor, cod_uf) para o tipo character.","code":""},{"path":"https://leoniedu.github.io/orce/reference/rename_ibge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Padroniza Nomes de Colunas para o Formato IBGE — rename_ibge","text":"","code":"df <- data.frame(   COD_SETOR = c(\"1234567\", \"8901234\"),   NOME_muni = c(\"São Paulo\", \"Rio de Janeiro\"),   abbrev_state = c(\"SP\", \"RJ\") )  df_padronizado <- rename_ibge(df) print(df_padronizado) #>     setor      nome_muni uf_sigla #> 1 1234567      São Paulo       SP #> 2 8901234 Rio de Janeiro       RJ #   setor        municipio_nome uf_sigla # 1 1234567        São Paulo       SP # 2 8901234 Rio de Janeiro       RJ"}]
